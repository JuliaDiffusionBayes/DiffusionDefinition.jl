#===============================================================================

        Macros for generating a collection of helper functions that
        are required to perform conjugate updates in `DiffusionMCMC.jl`.
        If you don't use `DiffusionMCMC.jl`, then don't worry about
        this file, as the macros below and the autogenerated functions
        that they produce will most likely be of no use to you.

===============================================================================#

#=
            These functions are overwritten when calling the
            @conjugate_gaussian macro
                                                                              =#
@doc raw"""
    phi(::Val{T}, t, x, P) where T

If the drift can be written in a form:
```math
b_θ(t, x) = θ^Tφ(t,x)+ϕ(t,x)
```
for parameters $θ$ that are being updated, then `phi` is a row of the matrix
$φ(t,x)$ that get's multiplied by the coordinate of a θ vector with a name `T`.
"""
phi(::Val, t, x, P) = error("not implemented")

"""
    num_non_hypo(Ptype::Type{T}) where T <: DiffusionProcess

Return a total number of coordinates of the diffusion process that have
non-degenerate noise structure. I.e. it is equal to the total number of
coordinates of the process minus the number of coordinates that have no direct
Wiener contribution.
"""
num_non_hypo(Ptype) = error("not implemented")

@doc raw"""
    hypo_a_inv(t, x, P)

Similar to $a^{-1}:=(σσ^T)^{-1}$, with the only exception that all of the zero
rows of $σ$ are first removed to yield $\hat{σ}$, and then,
$(\hat{σ} \hat{σ}^T)^{-1}$ is computed.
"""
hypo_a_inv(t, x, P) = error("not implemented")

@doc raw"""
    nonhypo(x, P)

Return the diffusion's coordinates that have direct contribution from some
non-degenerate Wiener terms, i.e. leave out coordinates whose Wiener term is
zero.
"""
nonhypo(x, P) = x

#TODO this is needed for the inverse solve!:
nonhypo_σ(t::Float64, x, P) = σ(t, x, P)

"""
    ignore_for_cu(::Val{T}, P) where T

A flag to indicate that a parameter with name `T` has no contribution to the
computation of conjugate updates.
"""
ignore_for_cu(::Val, P) = false

#=
                Main macro for Conjugate Gaussian updates
                                                                              =#
@doc raw"""
    @conjugate_gaussian DIFFUSION_NAME begin
        BODY
    end

Define helper functions for the conjugate gaussian updates of diffusion
DIFFUSION_NAME. In BODY information can be passed as a list with elements of the
form:

    :entry-name --> entry-value

The following entry names have special meaning: `:inplace`, `:nonhypo`,
`:hypo_a_inv`. Any other name is interpreted as a parameter name for which
function `phi` is defined. More precisely, the following can be defined:

# `:inplace`

    :inplace --> true

to indicate that compmutations are to be done in-place. Otherwise, by default
they are assumed to be done out-of-place.

# `:nonhypo`

    :nonhypo --> list-of-indices-with-non-degenerate-noise

e.g.

    :nonhypo --> [1,3,5]

to indicate which coordinates have non-degenerate (i.e. non-zero) Wiener term
Wiener term. It automatically defines `num_non_hypo` for the user.

!!! warning
    If no flag `:inplace --> true` is passed, then it will be assumed that
    computations are done **out-of-place** by default and then no matter what
    subset you passed it will be internally saved as an `SVector` so as to work
    as a static way of accessing a subset of parameters. Otherwise, no change
    will be made to `list-of-indices-with-non-degenerate-noise`.

# `hypo_a_inv`

    :hypo_a_inv --> f(t,x,P)

where `f` is a function that uses time variable `t`, state variable `x` and a
struct with the target diffusion law `P`.

# `phi` and `ignore_for_cu`

    :name-of-parameter --> (φ₁(t,x,P), φ₂(t,x,P), ...)

where `φ₁(t,x,P)` corresponds to all terms from the drift that are in the
**first** non-degenerate coordinate **and** that are multiplied by the parameter
with the name `name-of-parameter`, etc. Any parameters of `P` for which `φ` is
not defined will have a function `ignore_for_cu` defined for them automatically
and returning `true`.
"""
macro conjugate_gaussian(diff_name, ex::Expr)
    parse_conjug_gsn(diff_name, MacroTools.striplines(ex))
end

function parse_conjug_gsn(diff_name, ex::Expr)
    fns = []
    declared_inplace = findfirst(line->line.args[1]==:inplace, ex.args)
    inplace = ( declared_inplace == nothing ? false : declared_inplace )
    #NOTE currently only out of place supported
    @assert !inplace
    pnames = Symbol[]

    for line in ex.args
        @assert line.head == :-->
        name, args = eval(line.args[1]), line.args[2]
        if name == :inplace
            continue
        elseif name == :nonhypo
            push!(fns, define_nonhypo(diff_name, Val(inplace), args))
            push!(fns, define_num_non_hypo(diff_name, length(eval(args))))
        elseif (name == :hypo_a_inv)
            push!(fns, define_a_inv(diff_name, args))
        else
            push!(fns, define_phi(diff_name, name, args))
            push!(pnames, name)
        end
    end

    additional_params = [
        p for p in parameter_names(eval(diff_name)) if !(p in pnames)
    ]
    for p in additional_params
        push!(fns, define_phi_omission(diff_name, p))
    end

    for fn in fns
        eval(fn)
    end

    #[println(f) for f in fns]
    nothing
end

function define_num_non_hypo(diff_name, args)
    fn_def = Expr(
        :call,
        :num_non_hypo,
        Expr(
            :(::),
            Expr(
                :curly,
                :Type,
                Expr(
                    :(<:),
                    diff_name,
                )
            )
        )
    )
    @assert typeof(args) <: Integer

    fn_body = Expr(
        :block,
        Expr(
            :call,
            :Val,
            args
        )
    )

    Expr(
        :macrocall,
        Symbol("@inline"),
        :(#= none:1 =#),
        Expr(:(=), fn_def, fn_body)
    )
end

function define_nonhypo(diff_name, ::Val{false}, args)
    coords = eval(args)
    N = length(coords)

    fn_def = Expr(
        :call,
        :nonhypo,
        :x,
        Expr(
            :(::),
            :P,
            diff_name,
        ),
    )

    fn_body = Expr(
        :block,
        Expr(
            :ref,
            :x,
            Expr(
                :call,
                Expr(
                    :curly,
                    :SVector,
                    N,
                    Int64
                ),
                args,
            )
        )
    )

    Expr(
        :macrocall,
        Symbol("@inline"),
        :(#= none:1 =#),
        Expr(:(=), fn_def, fn_body),
    )
    #Expr(:(=), fn_def, fn_body)
end

function define_a_inv(diff_name, args)
    fn_def = Expr(
        :call,
        :hypo_a_inv,
        :t,
        :x,
        Expr(
            :(::),
            :P,
            diff_name,
        ),
    )
    Expr(:(=), fn_def, args)
end

function define_phi(diff_name, name, args)
    fn_def = Expr(
        :call,
        :phi,
        Expr(
            :(::),
            Expr(
                :curly,
                :Val,
                QuoteNode(name),
            )
        ),
        :t,
        :x,
        Expr(
            :(::),
            :P,
            diff_name,
        ),
    )

    Expr(:(=), fn_def, args)
end


function define_phi_omission(diff_name, name)
    fn_def = Expr(
        :call,
        :ignore_for_cu,
        Expr(
            :(::),
            Expr(
                :curly,
                :Val,
                QuoteNode(name),
            )
        ),
        Expr(
            :(::),
            :P,
            diff_name,
        ),
    )
    Expr(
        :macrocall,
        Symbol("@inline"),
        :(#= none:1 =#),
        Expr(
            :(=),
            fn_def,
            Expr(
                :block,
                true
            )
        )
    )
end
