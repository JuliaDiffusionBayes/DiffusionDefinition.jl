<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sampling trajectories · DiffusionDefinition.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DiffusionDefinition.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/package_overview/">Get started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../defining_diffusions/">Defining diffusions</a></li><li><a class="tocitem" href="../drift_and_volatility/">Drift and volatility</a></li><li class="is-active"><a class="tocitem" href>Sampling trajectories</a><ul class="internal"><li><a class="tocitem" href="#Trajectories-1"><span>Trajectories</span></a></li><li><a class="tocitem" href="#Sampling-Wiener-process-1"><span>Sampling Wiener process</span></a></li><li><a class="tocitem" href="#Sampling-diffusion-processes-1"><span>Sampling diffusion processes</span></a></li><li><a class="tocitem" href="#Plotting-the-results-1"><span>Plotting the results</span></a></li></ul></li><li><a class="tocitem" href="../functionals_of_paths/">Computing path-functionals</a></li><li><a class="tocitem" href="../load_diff/">Loading diffusions</a></li><li><a class="tocitem" href="../convenience_functions/">Utility functions</a></li><li><a class="tocitem" href="../buffers/">(TODO) Buffers</a></li><li><a class="tocitem" href="../state_space/">(TODO) State space restrictions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to...</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how_to_guides/combine_forwarddiff/">(TODO) Leverage ForwardDiff</a></li><li><a class="tocitem" href="../../how_to_guides/sample_brownian_bridges/">(TODO) Sample Brownian bridges</a></li><li><a class="tocitem" href="../../how_to_guides/sample_diffusion_bridges/">(TODO) Sample Diffusion bridges</a></li><li><a class="tocitem" href="../../how_to_guides/customize_my_diffusion_plots/">(TODO) Customize my diffusion plots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/simple_lorenz/">(TODO) Sampling Lorenz system</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Predefined Diffusions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../predefined_processes/lotka_volterra/">Lotka-Volterra system</a></li><li><a class="tocitem" href="../../predefined_processes/sine/">Sine diffusion</a></li><li><a class="tocitem" href="../../predefined_processes/sir/">SIR model</a></li><li><a class="tocitem" href="../../predefined_processes/lorenz63/">Lorenz63 system</a></li><li><a class="tocitem" href="../../predefined_processes/lorenz96/">Lorenz96 system</a></li><li><a class="tocitem" href="../../predefined_processes/favetto_samson/">(TODO) Favetto-Samson model</a></li><li><a class="tocitem" href="../../predefined_processes/prokaryote/">Prokaryotic autoregulatory gene network</a></li><li><a class="tocitem" href="../../predefined_processes/fitzhugh_nagumo/">FitzHugh-Nagumo model</a></li><li><a class="tocitem" href="../../predefined_processes/jansen_rit/">Jansen-Rit model</a></li></ul></li><li><a class="tocitem" href="../../post_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href>Sampling trajectories</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sampling trajectories</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl/blob/master/docs/src/manual/sampling.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sampling-diffusion-trajectories-1"><a class="docs-heading-anchor" href="#Sampling-diffusion-trajectories-1">Sampling diffusion trajectories</a><a class="docs-heading-anchor-permalink" href="#Sampling-diffusion-trajectories-1" title="Permalink"></a></h1><p>This package extends functions <code>Random.rand!</code> and <code>Base.rand</code> to sampling of trajectories of diffusion processes.</p><h2 id="Trajectories-1"><a class="docs-heading-anchor" href="#Trajectories-1">Trajectories</a><a class="docs-heading-anchor-permalink" href="#Trajectories-1" title="Permalink"></a></h2><p>The containers for sampled trajectories are instances of <code>Trajectory</code> from the package <a href="https://github.com/mschauer/Trajectories.jl">Trajectories.jl</a>. The functions exported by <code>Trajectories.jl</code> are re-exported by this package. The most literal way of defining trajectories is to directly pass already initialized and sized containers (or iterators), for instance</p><pre><code class="language-julia">tt = 0.0:0.01:1.0
xx = [zeros(Float64, 10) for _ in tt]
path = trajectory(tt, xx)</code></pre><p>However, we may also be more concise and let <code>trajectory</code> initialize the path containers for us:</p><pre><code class="language-julia"># for mutable types we need to pass DataType as well as dimension
path_mutable = trajectory(tt, Vector{Float64}, 10)
# for immutable types the dimension is inferred from the DataType
path_mutable = trajectory(tt, SVector{10,Float64})</code></pre><p>Finally, if we are initializing containers for a specific diffusion, then we may utilize the <a href="../drift_and_volatility/#default_types_for_P-1">default types</a> defined for this law together with information about diffusion&#39;s dimensions. For instance:</p><pre><code class="language-julia">P = Lorenz(10.0, 8.0/3.0, 28.0, 0.2)
paths = trajectory(tt, P)
XX, WW = paths.process, paths.wiener</code></pre><p>Or optionally specify the types ourselves:</p><pre><code class="language-julia">P = Lorenz(10.0, 8.0/3.0, 28.0, 0.2)
paths = trajectory(
    tt,
    P,
    Vector{Float64}, # process DataType
    Vector{Float64}, # Wiener DataType
)
X, W = paths.process, paths.wiener</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can also define multiple trajectories at once by passing multiple time segments, for instance</p><pre><code class="language-julia">dt = 0.01
paths = trajectory([0.0:dt:1.0, 1.0:dt:2.0, 2.0:dt:3.0], P)
# XX below contains three trajectories and so does WW
XX, WW = paths.process, paths.wiener</code></pre></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you need to call diffusion samplers multiple times (because you use them, say, in an MCMC setting), then initializing trajectories once and passing them around to sampling functions will massively improve the overall performance of your algorithms. However, if all you want to do is sample the trajectory once or a couple of times, then you don&#39;t need to worry about initializing trajectories yourself and let it be done by the <code>rand</code> function.</p></div></div><p>The time vector and path vector can be inspected by accessing fields <code>t</code> and <code>x</code> respectively:</p><pre><code class="language-julia">_time, _path = XX.t, XX.x</code></pre><p>See the <a href="https://github.com/mschauer/Trajectories.jl">README.md of Trajectories</a> for more details regarding other functionality implemented for <code>Trajectory</code>&#39;ies.</p><h2 id="Sampling-Wiener-process-1"><a class="docs-heading-anchor" href="#Sampling-Wiener-process-1">Sampling Wiener process</a><a class="docs-heading-anchor-permalink" href="#Sampling-Wiener-process-1" title="Permalink"></a></h2><p>In this package sampling of diffusion paths is always done on the basis of sampling the Wiener process first, treating it as a driving Brownian motion and then <code>solve!</code>ing the trajectory of the process based on that. The simplest way of sampling a Wiener process is to call:</p><pre><code class="language-julia">y1 = ... # define a starting point
W = rand(Wiener(), tt, y1)</code></pre><p>The dimensions and DataType of the Wiener process&#39;s trajectory are going to be inferred from the starting point <code>y1</code>.</p><p>Most often however, we need to sample the <strong>standard</strong> Brownian motion. For that reason we may omit <code>y1</code> and it will be initialized to <code>zero</code>. In this case <code>rand</code> will use information contained in the struct <code>Wiener</code> to infer the dimension and DataType, for instance:</p><pre><code class="language-julia">W = rand(Wiener(4, ComplexF64), tt)</code></pre><p>to sample a four-dimensional complex-valued Brownian motion (with <code>Float64</code> complex numbers).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If <code>y1</code> is not specified the DataType of state space will be set to <code>SVector</code> by default. To change this default behaviour you must overwrite the <code>zero</code> function to:</p><pre><code class="language-julia">Base.zero(w::Wiener{D,T}) where {D,T} = zeros(T, D)</code></pre><p>say, to use <code>Vector</code>s instead.</p></div></div><p>Alternatively, to avoid implicit allocation of space by <code>rand</code> we may pass a pre-initialized <code>Trajectory</code> to <code>rand!</code>:</p><pre><code class="language-julia">rand!(Wiener(), W)
# OR
rand!(wiener(), W, y1) # The first letter in `Wiener()` may be capital or not</code></pre><p>Note that in this case there is no need to decorate <code>Wiener</code> with additional type and dimension information as it is automatically inferred from the <code>Trajectory</code> container.</p><h2 id="Sampling-diffusion-processes-1"><a class="docs-heading-anchor" href="#Sampling-diffusion-processes-1">Sampling diffusion processes</a><a class="docs-heading-anchor-permalink" href="#Sampling-diffusion-processes-1" title="Permalink"></a></h2><p>The simplest way of sampling a diffusion trajectory is to call:</p><pre><code class="language-julia">P = Lorenz(10.0, 8.0/3.0, 28.0, 0.2)
y1 = ... # define a starting point
tt = 0.0:0.001:10.0
X = rand(P, tt, y1)</code></pre><p>The type used for states is going to be inferred from the starting point and the dimensions of the Wiener and diffusion processes will be inferred from <code>P</code>. The decision about in-place vs out-of-place computation will be made based on the inferred type.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>y1</code> can also be left unspecified, then, the trajectory will start from <code>zero</code> and the default diffusion type of <code>P</code> will be used. Nonetheless, for many diffusion laws starting from <code>zero</code> might not make much sense, so this use is discouraged.</p></div></div><p><code>rand</code> for diffusions is a convenience function that wraps:</p><ul><li>initialization of trajectories <code>X</code> and <code>W</code> for the diffusion and Wiener paths respectively</li><li>sampling Wiener path <code>W</code></li><li><code>solve!</code>ing the path <code>X</code> from the driving Brownian motion based on the Euler-Maruyama scheme.</li></ul><p>If you care about performance issues—say <code>X</code> needs to be re-sampled multiple times—then you might want to perform these steps by hand. I.e.</p><pre><code class="language-julia"># initialize containers:
X, W = trajectory(P, tt)
y1 = ...
# sample Wiener path:
rand!(Wiener(), W)
# solve for the process trajectory
DD.solve!(X, W, P, y1) # additionally pass `buffer` for in-place computations</code></pre><p>Calling <code>rand!</code> and <code>DD.solve!</code> over and over again is much quicker than calling <code>rand</code> multiple times.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><code>rand</code> and <code>rand!</code> functions by default use the default pseudo-random number generator from the package <a href="https://docs.julialang.org/en/v1/stdlib/Random/">Random.jl</a>. If you wish to use your own pseudo-random number generator then pass it as an additional first argument, for instance: <code>rand(RNG, Wiener(), tt)</code>.</p></div></div><h2 id="Plotting-the-results-1"><a class="docs-heading-anchor" href="#Plotting-the-results-1">Plotting the results</a><a class="docs-heading-anchor-permalink" href="#Plotting-the-results-1" title="Permalink"></a></h2><p>We provide plotting recipes for the <code>Trajectory</code> objects, so the <code>plot</code> function can be used to visualize the sampled trajectories very easily. Pass <code>Val(:vs_time)</code> to plot multiple (or single) trajectories vs time variable. Pass <code>Val(:x_vs_y)</code> to plot two coordinates against each other. Specify coordinates with a named argument <code>coords</code>. Otherwise, decorate your plots as you would otherwise by calling a <code>plot</code> function. For instance, to plot <code>X[1]</code> against <code>X[3]</code> call:</p><pre><code class="language-julia">using Plots
plot(X, Val(:x_vs_y); coords=[1,3])</code></pre><p>To plot all coordinates against time call:</p><pre><code class="language-julia">plot(X, Val(:vs_time))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../drift_and_volatility/">« Drift and volatility</a><a class="docs-footer-nextpage" href="../functionals_of_paths/">Computing path-functionals »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 26 April 2020 16:34">Sunday 26 April 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
