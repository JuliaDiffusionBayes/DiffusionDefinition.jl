<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Drift and volatility · DiffusionDefinition.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DiffusionDefinition.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DiffusionDefinition.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/package_overview/">Get started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../defining_diffusions/">Defining diffusions</a></li><li class="is-active"><a class="tocitem" href>Drift and volatility</a><ul class="internal"><li><a class="tocitem" href="#default_types_for_P-1"><span>Telling Julia whether to use (<code>DD.b</code>, <code>DD.σ</code>) or (<code>DD.b!</code>, <code>DD.σ!</code>)</span></a></li></ul></li><li><a class="tocitem" href="../sampling/">Sampling trajectories</a></li><li><a class="tocitem" href="../functionals_of_paths/">Computing path-functionals</a></li><li><a class="tocitem" href="../load_diff/">Loading diffusions</a></li><li><a class="tocitem" href="../convenience_functions/">Utility functions</a></li><li><a class="tocitem" href="../buffers/">Buffers</a></li><li><a class="tocitem" href="../state_space/">State space restrictions</a></li><li><a class="tocitem" href="../reparameterization/">Reparameterizations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to...</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how_to_guides/sample_brownian_bridges/">How to sample Brownian bridges</a></li><li><a class="tocitem" href="../../how_to_guides/sample_diffusion_bridges/">(TODO) How to sample Diffusion bridges</a></li><li><a class="tocitem" href="../../how_to_guides/sample_complex_valued/">How to sample complex-valued diffusions</a></li><li><a class="tocitem" href="../../how_to_guides/customize_my_diffusion_plots/">(TODO) How to customize my diffusion plots</a></li><li><a class="tocitem" href="../../how_to_guides/expect_of_gradient/">(TODO) How to compute expectation of gradients of functionals</a></li><li><a class="tocitem" href="../../how_to_guides/higher_order_derivatives/">(TODO) How to compute higher order derivatives of functionals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/simple_lorenz/">(TODO) Sampling Lorenz system</a></li><li><a class="tocitem" href="../../tutorials/in_place_vs_out_of_place/">(TODO) In-place vs out-of-place methods</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Predefined Diffusions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../predefined_processes/lotka_volterra/">Lotka-Volterra system</a></li><li><a class="tocitem" href="../../predefined_processes/sine/">Sine diffusion</a></li><li><a class="tocitem" href="../../predefined_processes/sir/">SIR model</a></li><li><a class="tocitem" href="../../predefined_processes/lorenz63/">Lorenz63 system</a></li><li><a class="tocitem" href="../../predefined_processes/lorenz96/">Lorenz96 system</a></li><li><a class="tocitem" href="../../predefined_processes/favetto_samson/">Favetto-Samson model</a></li><li><a class="tocitem" href="../../predefined_processes/prokaryote/">Prokaryotic autoregulatory gene network</a></li><li><a class="tocitem" href="../../predefined_processes/fitzhugh_nagumo/">FitzHugh-Nagumo model</a></li><li><a class="tocitem" href="../../predefined_processes/jansen_rit/">Jansen-Rit model</a></li></ul></li><li><a class="tocitem" href="../../post_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href>Drift and volatility</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Drift and volatility</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl/blob/master/docs/src/manual/drift_and_volatility.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Defining-the-drift-and-the-volatility-coefficient-1"><a class="docs-heading-anchor" href="#Defining-the-drift-and-the-volatility-coefficient-1">Defining the drift and the volatility coefficient</a><a class="docs-heading-anchor-permalink" href="#Defining-the-drift-and-the-volatility-coefficient-1" title="Permalink"></a></h1><hr/><p>To complete the definition of a diffusion process we need to specify its drift, as well as its volatility coefficient. For the <code>Lorenz</code> example from the <a href="../defining_diffusions/#Lorenz_example-1">previous section</a> we can do this by writing:</p><pre><code class="language-julia">const DD = DiffusionDefinition
using StaticArrays

function DD.b(t, x, P::Lorenz)
    @SVector [
        P.p1*(x[2]-x[1]),
        P.p2*x[1] - x[2] - x[1]*x[3],
        x[1]*x[2] - P.p3*x[3]
    ]
end

DD.σ(t, x, P::Lorenz) = SDiagonal(P.σ, P.σ, P.σ)</code></pre><p>The two functions above are <strong>out-of-place</strong> i.e. they return new vectors (that live on a stack, because of <code>StaticArrays</code>). We may alternatively define the drift and diffusion coefficients to be <strong>in-place</strong> as follows:</p><pre><code class="language-julia">function DD.b!(buffer, t, x, P::Lorenz)
    buffer.b[1] = P.p1*(x[2]-x[1])
    buffer.b[2] = P.p2*x[1] - x[2] - x[1]*x[3]
    buffer.b[3] = x[1]*x[2] - P.p3*x[3]
end

DD.σ!(buffer, t, x, P::Lorenz) = (buffer.σ.diag .= P.σ)</code></pre><p>In this case case the output is saved to a <code>buffer</code>, which must have appropriate fields <code>b</code> and <code>σ</code> with enough pre-allocated space (see also <a href="../buffers/#explain_buffers-1">the section on buffers</a>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ul><li>all of the functions <code>DD.b</code>, <code>DD.b!</code>, <code>DD.σ</code> and <code>DD.σ!</code> are defined to overload the functionality inside the <code>DiffusionDefinition</code> module (accessing it via <code>DD</code>) and <strong>NOT</strong> the <code>Main</code> module.</li><li>the arguments for the out-of-place method are <code>(t, x, P::DIFFUSION_NAME)</code>, whereas those for in-place are <code>(buffer, t, x, P::DIFFUSION_NAME)</code>.</li></ul></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Always use <code>StaticArrays</code> for out-of-place drift and volatility! If functions using <code>DD.b</code> and <code>DD.σ</code> are faster with regular arrays, then you shouldn&#39;t be using out-of-place methods in the first place, but <code>DD.b!</code> and <code>DD.σ!</code> instead. A general rule of thumb is to use <code>DD.b</code> and <code>DD.σ</code> for low dimensional diffusions (up to dimension <code>~10</code> for elliptic diffusions with dense volatility coefficients or up to dimension <code>~100</code> for those with sparse volatility coefficients) and use in-place methods otherwise.</p></div></div><h2 id="default_types_for_P-1"><a class="docs-heading-anchor" href="#default_types_for_P-1">Telling Julia whether to use (<code>DD.b</code>, <code>DD.σ</code>) or (<code>DD.b!</code>, <code>DD.σ!</code>)</a><a class="docs-heading-anchor-permalink" href="#default_types_for_P-1" title="Permalink"></a></h2><p>Some functions implemented in this package have two versions: one relying on out-of-place methods, another on in-place methods. For instance:</p><article class="docstring"><header><a class="docstring-binding" id="DiffusionDefinition.solve!-NTuple{4,Any}" href="#DiffusionDefinition.solve!-NTuple{4,Any}"><code>DiffusionDefinition.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve!(XX, WW, P, y1)</code></pre><p>Compute a trajectory, started from <code>y1</code> and following the diffusion law <code>P</code>, from the sampled Wiener process <code>WW</code>. Save the sampled path in <code>XX</code>. Return prematurely with a <code>false</code> massage if the numerical scheme has led to the solver violating the state-space restrictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl/blob/00b2a69f8240fd071753063c3c4adfdcd465dec2/src/sampling.jl#LL161-L168">source</a></section></article><p>and</p><article class="docstring"><header><a class="docstring-binding" id="DiffusionDefinition.solve!-NTuple{5,Any}" href="#DiffusionDefinition.solve!-NTuple{5,Any}"><code>DiffusionDefinition.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve!(XX, WW, P, y1, buffer)</code></pre><p>Same as <code>solve!(XX, WW, P, y1)</code>, but additionally provides a pre-allocated buffer for performing in-place computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl/blob/00b2a69f8240fd071753063c3c4adfdcd465dec2/src/sampling.jl#LL173-L178">source</a></section></article><p>Calling one or the other will tell Julia which pair of functions (<code>DD.b</code>, <code>DD.σ</code>) or (<code>DD.b!</code>, <code>DD.σ!</code>) to use. However, most functions do not explicitly come in two versions, and instead, they rely on some hint from the user to decide on the mode of computation. There are two ways in which Julia can be given such hints:</p><ul><li>If the function accepts optional inputs (such as a starting point) or expects to receive containers that the results are saved into (such as containers for diffusion paths), then the <code>DataType</code> of said inputs will be used to decide on the mode of computation (if <code>DataType</code> used for state space is immutable, then out-of-place methods are used, otherwise in-place methods are used). These hints will overwrite the second method below.</li><li>Sometimes no such inputs can be passed or there is an option of relying on defaults. In that case <code>Julia</code> will use default information specified by functions:</li></ul><article class="docstring"><header><a class="docstring-binding" id="DiffusionDefinition.default_type" href="#DiffusionDefinition.default_type"><code>DiffusionDefinition.default_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_type(::DiffusionProcess{T,DP})</code></pre><p>Allows for inference of data type that encodes the state space of a given diffusion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl/blob/00b2a69f8240fd071753063c3c4adfdcd465dec2/src/standard_functions.jl#LL29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffusionDefinition.default_wiener_type" href="#DiffusionDefinition.default_wiener_type"><code>DiffusionDefinition.default_wiener_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_wiener_type(::DiffusionProcess{T,DP,DW})</code></pre><p>Allows for inference of data type that encodes the state space of the Brownian motion driving a given diffusion process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl/blob/00b2a69f8240fd071753063c3c4adfdcd465dec2/src/standard_functions.jl#LL37-L42">source</a></section></article><p>By default, these two are set to <code>StaticArrays</code> resulting in out-of-place computations by default. To change that, overwrite the two functions for your diffusion type. For instance, for the <code>Lorenz</code> example, to change the default mode of computation to out-of-place write:</p><pre><code class="language-julia">default_type(::Lorenz) = Vector{Float64}
default_wiener_type(::Lorenz) = Vector{Float64}</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../defining_diffusions/">« Defining diffusions</a><a class="docs-footer-nextpage" href="../sampling/">Sampling trajectories »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 15 May 2020 14:42">Friday 15 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
