var documenterSearchIndex = {"docs":
[{"location":"predefined_processes/prokaryote/#Prokaryotic-autoregulatory-gene-network-1","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"","category":"section"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"Chemical Langevin equation for a simple system describing production of a protein that is repressing its own production. The process under consideration is a 4-dimensional diffusion driven by an 8-dimensional Wiener process. The stochastic differential equation takes a form:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":" dd X_t = Slefttheta circ h(X_t)rightdd t + Sodot gamma(thetacirc h(X_t)) dd W_t","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"where circRR^dto RR^d is a component-wise multiplication:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(mu circ nu)_i = mu_inu_iquad i=1dotsd","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"the custom operation odotRR^dtimes dtoRR^dtimes d is defined via:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(Modot mu)_ij = M_ijmu_jquad i=1dotsd j=1dotsd","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"the function gammaRR^dto RR^d is a component-wise square root:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(gamma(mu))_i=sqrtmu_iquad i=1dotsd","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"S is the stoichiometry matrix:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"S=left\n  beginmatrix\n  0  0  1  0  0  0  -1  0 \n  0  0  0  1  -2  2  0  -1 \n  -1  1  0  0  1  -1  0  0 \n  -1  1  0  0  0  0  0  0\n  endmatrix\nright","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"and the function h is given by:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"h(x) = (x_3x_4 K-x_4 x_4 x_1 x_2(x_2-1)2 x_3 x_1 x_2)^T","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"The chemical Langevin equation above has been derived as an approximation to a chemical reaction network","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"beginalign*\nmathcalR_1textttDNA + textttP_2rightarrowtextttDNAcdottextttP_2\nmathcalR_2textttDNAcdottextttP_2rightarrowtextttDNA+textttP_2\nmathcalR_3textttDNArightarrowtextttDNA+textttRNA\nmathcalR_4textttRNArightarrowtextttRNA+textttP\nmathcalR_52textttPrightarrowtextttP_2\nmathcalR_6textttP_2rightarrow 2textttP\nmathcalR_7textttRNArightarrowemptyset\nmathcalR_8textttPrightarrowemptyset\nendalign*","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"with reactant constants given by the vector theta.","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"Can be imported with","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"@load_diffusion Prokaryote","category":"page"},{"location":"predefined_processes/prokaryote/#Example-1","page":"Prokaryotic autoregulatory gene network","title":"Example","text":"","category":"section"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion Prokaryote\nθ, K = [0.1, 0.7, 0.35, 0.2, 0.1, 0.9, 0.3, 0.1], 10.0\nP = Prokaryote(θ..., K)\ntt, y1 = 0.0:0.001:10.0, @SVector [8.0, 8.0, 8.0, 5.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), label=[\"RNA\" \"P\" \"P₂\" \"DNA\"], size=(800,300))","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(Image: prokaryote)","category":"page"},{"location":"predefined_processes/prokaryote/#Auxiliary-diffusion-1","page":"Prokaryotic autoregulatory gene network","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"We additionally define a linear diffusion that can be used in the setting of guided proposals. It is defined as a solution to the following SDE:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"...","category":"page"},{"location":"manual/functionals_of_paths/#Computing-path-functionals-when-sampling-1","page":"Computing path-functionals","title":"Computing path-functionals when sampling","text":"","category":"section"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"rand, rand! and solve! accept an additional, named argument f—a functional of a path. By default it is turned off, but we may define some Julia function and pass it on to rand, rand! or solve! to be evaluated during the call to solve!. For out-of-place computations three versions of function need to be defined:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"# called at the very start of solve!\nf_accum = foo(P, y)\n# called at the beginning of every iteration of the Euler-Maruyama scheme\nf_accum = foo(f_accum, P, y, t, dt, dW, i)\n# called at the very end, just before return statement\nf_accum = foo(f_accum, P, y, Val(:final))","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"For in-place computations these three functions must have a slightly different form","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"# called at the very start of solve!\nf_accum = foo(buffer, P, y) # the buffer needs to accommodate the needs of function f\n# called at the beginning of every iteration of the Euler-Maruyama scheme\nfoo(buffer, P, y, tt[i-1], dt, i-1)\n# called at the very end, just before return statement\nfoo(buffer, P, y, _FINAL)","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"If foo is appropriately defined, then we may pass it to, say, rand as follows:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"X, foo_result = rand(P, tt, y1; f=foo)","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"Then, the output of rand is not only the sampled path X, but also the result of evaluating the functional defined by foo.","category":"page"},{"location":"manual/functionals_of_paths/#Example-1","page":"Computing path-functionals","title":"Example","text":"","category":"section"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"As an example, consider computing:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"Y_0^3e^-frac1100int_0^T (Y_t^1)^2e^-tdd t + Y_T^2100 ","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"for Y a path drawn under the Lorenz law, and Y^i representing its ith coordinate. We may define functions foo as follows:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"foo(P::Lorenz, y) = log(y[3])\nfoo(f_accum, P::Lorenz, y, t, dt, dW, i) = f_accum - exp(-t)*y[1]^2/100.0*dt\nfoo(f_accum, P::Lorenz, y, ::Val{:final}) = exp(f_accum + y[2]/100.0)\nX, foo_result = rand(P, tt, y1; f=foo)","category":"page"},{"location":"manual/functionals_of_paths/#Gradients-of-path-functionals-when-sampling-1","page":"Computing path-functionals","title":"Gradients of path-functionals when sampling","text":"","category":"section"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"Why would we care about computing path-functionals at the time of sampling instead of simply doing so after the path has been sampled and stored in a Trajectory? The answer is: we can leverage Julia's automatic differentiation implemented in the package ForwardDiff.jl to compute gradients (and Hessians) of said functionals with respect to, say, a starting point or diffusion's parameters in a very efficient manner and without having to strain the memory by expanding the DataType used in Trajectory'ies.","category":"page"},{"location":"manual/functionals_of_paths/#Example-2","page":"Computing path-functionals","title":"Example","text":"","category":"section"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"For instance, in the example above, if we wanted to compute gradients with respect to diffusion parameters we can do the following:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"# need a wrapper around foo\nfunction foobar(θ)\n    P = Lorenz(θ...)\n    _, foo_result = DD.solve!(X, W, P, y1_θ; f=foo)\n    foo_result\nend\n# stating parameters\nθ° = @SVector[10.0, 28.0, 8.0/3.0, 1.0]\ntt = 0.0:0.001:10.0\ny1 = @SVector [-10.0, -10.0, 25.0]\nX, W = trajectory(tt, P)\nrand!(Wiener(), W)\n# gradient preparation\ny1_θ_type = similar_type(θ°, Dual{Tag{typeof(foobar),eltype(y1)},eltype(y1),length(θ)}, Size(y1))\ny1_θ = y1_θ_type(y1)\n\ngrad_at_θ° = ForwardDiff.gradient(foobar, θ°)","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"The trajectories X and W are of regular, default datatype specified by P (and do not use Duals from ForwardDiff). y1 needs to be already of the type that uses Dual numbers (that's how solve! knows what DataType to use).","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"The steps above are packaged in a convenience function","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"DiffusionDefinition.grad_θ","category":"page"},{"location":"manual/functionals_of_paths/#DiffusionDefinition.grad_θ","page":"Computing path-functionals","title":"DiffusionDefinition.grad_θ","text":"grad_θ(θ, y1, W, X, Law, f)\n\nCompute ∇f with respect to parameters θ for a fixed Wiener path W. X is a container where the the trajectory computed for the Wiener path W under the law Law(θ) will be stored. y1 is the starting position.\n\n\n\n\n\n","category":"function"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"so all the steps above are encapsulated by a call","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"# stating parameters\nθ° = @SVector[10.0, 28.0, 8.0/3.0, 1.0]\ntt = 0.0:0.001:10.0\ny1 = @SVector [-10.0, -10.0, 25.0]\nX, W = trajectory(P, tt)\nrand!(Wiener(), W)\n\n# gradient computation\ngrad_at_θ° = grad_θ(θ°, y1, W, X, Lorenz, foo)","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"Additionally, we provide:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"DiffusionDefinition.grad_y1","category":"page"},{"location":"manual/functionals_of_paths/#DiffusionDefinition.grad_y1","page":"Computing path-functionals","title":"DiffusionDefinition.grad_y1","text":"grad_y1(y1, W, X, P, f)\n\nCompute ∇f with respect to the starting position y1 for a fixed Wiener path W. X is a container where the the trajectory computed for the Wiener path W under the law P will be stored.\n\n\n\n\n\n","category":"function"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"so that gradients with respect to a starting position may be computed as follows:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"P = Lorenz(θ°...)\nDD.grad_y1(y1, W, X, P, foo)","category":"page"},{"location":"how_to_guides/sample_diffusion_bridges/#How-to-sample-diffusion-bridges?-1","page":"How to sample Diffusion bridges?","title":"How to sample diffusion bridges?","text":"","category":"section"},{"location":"how_to_guides/sample_diffusion_bridges/#","page":"How to sample Diffusion bridges?","title":"How to sample Diffusion bridges?","text":"","category":"page"},{"location":"how_to_guides/sample_diffusion_bridges/#","page":"How to sample Diffusion bridges?","title":"How to sample Diffusion bridges?","text":"A diffusion bridge is a diffusion conditioned on its end-point. A diffusion bridge is a special type of a conditioned diffusion where the conditioning is on its end point.","category":"page"},{"location":"how_to_guides/sample_diffusion_bridges/#","page":"How to sample Diffusion bridges?","title":"How to sample Diffusion bridges?","text":"The most convenient, efficient and robust method of sampling conditioned diffusions (including diffusion bridges) is to use the package GuidedProposals.jl that has been designed to address precisely this problem.","category":"page"},{"location":"how_to_guides/sample_diffusion_bridges/#","page":"How to sample Diffusion bridges?","title":"How to sample Diffusion bridges?","text":"Alternatively, you may follow the tutorial on sampling diffusion bridges using  rejection and importance sampling with Wiener proposals. In vast majority of cases however, this last method will not be suitable for production models.","category":"page"},{"location":"how_to_guides/expect_of_gradient/#How-to-compute-expected-values-of-gradients-of-functionals?-1","page":"How to compute expectation of gradients of functionals?","title":"How to compute expected values of gradients of functionals?","text":"","category":"section"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"To compute expectations of gradients of functionals we may simply use Monte Carlo simulations. For instance, suppose we have a Lorenz system","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"@load_diffusion Lorenz\nθ° = [10.0, 28.0, 8.0/3.0, 1.0]\ntt = 0.0:0.001:10.0\ny1 = @SVector [-10.0, -10.0, 25.0]","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"and the following functional to compute","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"foo(P::Lorenz, y) = 0.0\nfoo(f_accum, P::Lorenz, y, t, dt, dW, i) = f_accum - exp(-t)*y[1]^2/1000.0*dt\nfoo(f_accum, P::Lorenz, y, ::Val{:final}) = exp(f_accum)","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"Then, we can use, say, function grad_θ that computes gradients with respect to the parameters and embed it in a Monte Carlo scheme as follows:","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"function expectation_of_grad(θ°, y1, W, X, Law, f, num_rep=1e4)\n    grads = map(1:num_rep) do i\n        rand!(Wiener(), W)\n        # gradient computation\n        DD.grad_θ(θ°, y1, W, X, Law, f)\n    end\n    E = sum(grads)/num_rep\n    C = mapreduce(g->(g-E)*(g-E)', +, grads)/num_rep\n    E, C\nend","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"We can now compute the expected values of gradients together with the covariance:","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"X, W = trajectory(tt, Lorenz(θ°...))\nE_grad, C_grad = expectation_of_grad(θ°, y1, W, X, Lorenz, foo)","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"which for this particular case yields:","category":"page"},{"location":"how_to_guides/expect_of_gradient/#","page":"How to compute expectation of gradients of functionals?","title":"How to compute expectation of gradients of functionals?","text":"julia> E_grad\n4-element SArray{Tuple{4},Float64,1,4} with indices SOneTo(4):\n  9.43393204196648e-5\n -0.0029595272871572606\n -0.024297701677402275\n  0.0001291653982423314\n\njulia> C_grad\n4×4 SArray{Tuple{4,4},Float64,2,16} with indices SOneTo(4)×SOneTo(4):\n  4.99701e-6   1.0669e-5    -3.05976e-5    4.25573e-5\n  1.0669e-5    4.34692e-5   -0.000240906   0.000171052\n -3.05976e-5  -0.000240906   0.00191821   -0.0010401\n  4.25573e-5   0.000171052  -0.0010401     0.000800068","category":"page"},{"location":"manual/sampling/#Sampling-diffusion-trajectories-1","page":"Sampling trajectories","title":"Sampling diffusion trajectories","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"This package extends functions Random.rand! and Base.rand to sampling of trajectories of diffusion processes.","category":"page"},{"location":"manual/sampling/#Trajectories-1","page":"Sampling trajectories","title":"Trajectories","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The containers for sampled trajectories are instances of Trajectory from the package Trajectories.jl. The functions exported by Trajectories.jl are re-exported by this package. The most literal way of defining trajectories is to directly pass already initialized and sized containers (or iterators), for instance","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"tt = 0.0:0.01:1.0\nxx = [zeros(Float64, 10) for _ in tt]\npath = trajectory(tt, xx)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"However, we may also be more concise and let trajectory initialize the path containers for us:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"# for mutable types we need to pass DataType as well as dimension\npath_mutable = trajectory(tt, Vector{Float64}, 10)\n# for immutable types the dimension is inferred from the DataType\npath_mutable = trajectory(tt, SVector{10,Float64})","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Finally, if we are initializing containers for a specific diffusion, then we may utilize the default types defined for this law together with information about diffusion's dimensions. For instance:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"P = Lorenz(10.0, 28.0, 8.0/3.0, 1.0)\npaths = trajectory(tt, P)\nXX, WW = paths.process, paths.wiener","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Or optionally specify the types ourselves:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"P = Lorenz(10.0, 28.0, 8.0/3.0, 1.0)\npaths = trajectory(\n    tt,\n    P,\n    Vector{Float64}, # process DataType\n    Vector{Float64}, # Wiener DataType\n)\nX, W = paths.process, paths.wiener","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"note: Note\nYou can also define multiple trajectories at once by passing multiple time segments, for instancedt = 0.01\npaths = trajectory([0.0:dt:1.0, 1.0:dt:2.0, 2.0:dt:3.0], P)\n# XX below contains three trajectories and so does WW\nXX, WW = paths.process, paths.wiener","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"tip: Tip\nIf you need to call diffusion samplers multiple times (because you are using them, say, in an MCMC setting), then initializing trajectories once and passing them around to sampling functions will massively improve the overall performance of your algorithms. However, if all you want to do is sample the trajectory once or a couple of times, then you don't need to worry about initializing trajectories yourself and let it be done by the rand function.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The time vector and path vector can be inspected by accessing fields t and x respectively:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"_time, _path = XX.t, XX.x","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"See the README.md of Trajectories for more details regarding other functionality implemented for Trajectory'ies.","category":"page"},{"location":"manual/sampling/#Sampling-Wiener-process-1","page":"Sampling trajectories","title":"Sampling Wiener process","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"In this package sampling of diffusion paths is always done on the basis of sampling the Wiener process first, treating it as a driving Brownian motion and then solve!ing the trajectory of the process based on that. The simplest way of sampling a Wiener process is to call:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"y1 = ... # define a starting point\nW = rand(Wiener(), tt, y1)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The dimensions and DataType of the Wiener process's trajectory are going to be inferred from the starting point y1.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Most often however, we need to sample the standard Brownian motion. For that reason we may omit y1 and it will be initialized to zero. In this case rand will use information contained in the struct Wiener to infer the dimension and DataType, for instance:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"W = rand(Wiener(4, ComplexF64), tt)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"to sample a four-dimensional complex-valued Brownian motion (with Float64 complex numbers).","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"warning: Warning\nIf y1 is not specified the DataType of state space will be set to SVector by default. To change this default behaviour you must overwrite the zero function to:Base.zero(w::Wiener{D,T}) where {D,T} = zeros(T, D)say, to use Vectors instead.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Alternatively, to avoid implicit allocation of space by rand we may pass a pre-initialized Trajectory to rand!:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"rand!(Wiener(), W)\n# OR\nrand!(wiener(), W, y1) # The first letter in `Wiener()` may be capital or not","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Note that in this case there is no need to decorate Wiener with additional type and dimension information as it is automatically inferred from the Trajectory container.","category":"page"},{"location":"manual/sampling/#Sampling-diffusion-processes-1","page":"Sampling trajectories","title":"Sampling diffusion processes","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The simplest way of sampling a diffusion trajectory is to call:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"P = Lorenz(10.0, 28.0, 8.0/3.0, 1.0)\ny1 = ... # define a starting point\ntt = 0.0:0.001:10.0\nX = rand(P, tt, y1)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The type used for states is going to be inferred from the starting point and the dimensions of the Wiener and diffusion processes will be inferred from P. The decision about in-place vs out-of-place computation will be made based on the inferred type.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"note: Note\ny1 can also be left unspecified, then, the trajectory will start from zero and the default diffusion type of P will be used. Nonetheless, for many diffusion laws starting from zero might not make much sense, so this use is discouraged.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"rand for diffusions is a convenience function that wraps:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"initialization of trajectories X and W for the diffusion and Wiener paths respectively\nsampling Wiener path W\nsolve!ing the path X from the driving Brownian motion based on the Euler-Maruyama scheme.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"If you care about performance issues—say X needs to be re-sampled multiple times—then you might want to perform these steps by hand. I.e.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"# initialize containers:\nX, W = trajectory(tt, P)\ny1 = @SVector [-10.0, -10.0, 25.0]\n# sample Wiener path:\nrand!(Wiener(), W)\n# solve for the process trajectory\nDD.solve!(X, W, P, y1) # additionally pass `buffer` for in-place computations","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Calling rand! and DD.solve! over and over again is much quicker than calling rand multiple times.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"tip: Tip\nrand and rand! functions by default use the default pseudo-random number generator from the package Random.jl. If you wish to use your own pseudo-random number generator then pass it as an additional first argument, for instance: rand(RNG, Wiener(), tt).","category":"page"},{"location":"manual/sampling/#Plotting-the-results-1","page":"Sampling trajectories","title":"Plotting the results","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"We provide plotting recipes for the Trajectory objects, so the plot function can be used to visualize the sampled trajectories very easily. Pass Val(:vs_time) to plot multiple (or single) trajectories vs time variable. Pass Val(:x_vs_y) to plot two coordinates against each other. Specify coordinates with a named argument coords. Otherwise, decorate your plots as you would otherwise by calling a plot function. For instance, to plot X[1] against X[3] call:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"using Plots\nplot(X, Val(:x_vs_y); coords=[1,3])","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"(Image: lorenz_x_vs_y)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"To plot all coordinates against time call:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"plot(X, Val(:vs_time))","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"(Image: lorenz_vs_time)","category":"page"},{"location":"manual/convenience_functions/#utility_functions-1","page":"Utility functions","title":"Auto-generated utility functions","text":"","category":"section"},{"location":"manual/convenience_functions/#","page":"Utility functions","title":"Utility functions","text":"","category":"page"},{"location":"manual/convenience_functions/#","page":"Utility functions","title":"Utility functions","text":"For each newly defined diffusion DiffusionProcess the package auto-generates some utility functions. They are not exported, but can be called by accessing through DiffusionDefinition module. These are:","category":"page"},{"location":"manual/convenience_functions/#","page":"Utility functions","title":"Utility functions","text":"Modules = [DiffusionDefinition]\nPages = [\"standard_functions.jl\"]","category":"page"},{"location":"manual/convenience_functions/#Base.eltype-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS where DW where DP}, Tuple{T}} where T","page":"Utility functions","title":"Base.eltype","text":"Base.eltype(::DiffusionProcess{T}) where T = T\n\nReturn the datatype that each coordinate of the stochastic process is stored in.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#Base.zero","page":"Utility functions","title":"Base.zero","text":"Base.zero(K::Type, D, ::Val)\n\nIf K is a mutable type, then create zeros of dimension D and entries with types eltype(K). Otherwise, calls regular zero(K).\n\n\n\n\n\n","category":"function"},{"location":"manual/convenience_functions/#Base.zero-Tuple{DiffusionDefinition.DiffusionProcess,Val{:process}}","page":"Utility functions","title":"Base.zero","text":"Base.zero(P::DiffusionProcess)\n\nInstantiate a zero element that can represent a state of a Brownian motion driving a diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#Base.zero-Tuple{DiffusionDefinition.DiffusionProcess,Val{:wiener}}","page":"Utility functions","title":"Base.zero","text":"Base.zero(P::DiffusionProcess)\n\nInstantiate a zero element that can represent a state of a diffusion.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.const_parameter_names-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.const_parameter_names","text":"const_parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters that are considered to be constant.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.const_parameter_names-Tuple{Type{#s12} where #s12<:DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.const_parameter_names","text":"const_parameter_names(P::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters that are considered to be constant.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.const_parameters-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.const_parameters","text":"const_parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value. Return only those parameteres that are considered to be constant.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.default_type-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS where DW}, Tuple{DP}, Tuple{T}} where DP where T","page":"Utility functions","title":"DiffusionDefinition.default_type","text":"default_type(::DiffusionProcess{T,DP})\n\nAllows for inference of data type that encodes the state space of a given diffusion.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.default_wiener_type-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS}, Tuple{DW}, Tuple{DP}, Tuple{T}} where DW where DP where T","page":"Utility functions","title":"DiffusionDefinition.default_wiener_type","text":"default_wiener_type(::DiffusionProcess{T,DP,DW})\n\nAllows for inference of data type that encodes the state space of the Brownian motion driving a given diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.diagonalBmat-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.diagonalBmat","text":"diagonalBmat(P::DiffusionProcess)\n\nIndicator for whether the B matrix (if exists) is represented by a diagonal matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.diagonaldiff-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.diagonaldiff","text":"diagonaldiff(P::DiffusionProcess)\n\nIndicator for whether the volatility coefficient is represented by a diagonal matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.dimension-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS}, Tuple{DW}, Tuple{DP}, Tuple{T}} where DW where DP where T","page":"Utility functions","title":"DiffusionDefinition.dimension","text":"dimension(::DiffusionProcess{T,DP,DW})\n\nReturn dimension of the stochastic process and driving Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.end_point_info-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.end_point_info","text":"end_point_info(P::DiffusionProcess)\n\nReturn information about the end-point (works only if some information of this kind has been passed at the time of defining a struct) TODO improve\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.end_point_info_names-Tuple{Type{#s12} where #s12<:DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.end_point_info_names","text":"end_point_info_names(P::DiffusionProcess)\n\nReturn names of information pieces about the end-point (works only if some information of this kind has been passed at the time of defining a struct) TODO improve\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.nonhypo_σ-Tuple{Tuple{T,S} where S<:Integer where T<:Number,Any,DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.nonhypo_σ","text":"nonhypo_σ((t,i)::IndexedTime, x, P::DiffusionProcess)\n\nReturn a sub-matrix of the full volatility matrix σ that consists of non-zero rows of σ.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.parameter_names-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.parameter_names","text":"parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.parameter_names-Tuple{Type{#s13} where #s13<:DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.parameter_names","text":"parameter_names(::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.parameters-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.parameters","text":"parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.sparseBmat-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.sparseBmat","text":"sparseBmat(P::DiffusionProcess)\n\nIndicator for whether the B matrix (if exists) is represented by a sparse matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.sparsediff-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.sparsediff","text":"sparsediff(P::DiffusionProcess)\n\nIndicator for whether the volatility coefficient is represented by a sparse matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.state_space-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS}}, Tuple{SS}, Tuple{DW}, Tuple{DP}, Tuple{T}} where SS where DW where DP where T","page":"Utility functions","title":"DiffusionDefinition.state_space","text":"state_space(::DiffusionProcess{T,DP,DW,SS})\n\nReturn the state space restrictions.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.var_parameter_names-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.var_parameter_names","text":"var_parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters that are considered to be variable.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.var_parameter_names-Tuple{Type{#s12} where #s12<:DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.var_parameter_names","text":"var_parameter_names(P::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters that are considered to be variable.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.var_parameters-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.var_parameters","text":"var_parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value. Return only those parameteres that are considered to be variable.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/swinging_pendulum/#tutorials_start-1","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"","category":"section"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"In this tutorial we will define a diffusion and simulate trajectories from it.","category":"page"},{"location":"tutorials/swinging_pendulum/#The-model-1","page":"Defining a diffusion process for a swinging pendulum","title":"The model","text":"","category":"section"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"We start with the differential equation for the angular position of a swinging pendulum, which is given by the second order ordinary differential equation","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":" fracdd^2 x(t)dd t^2 + θ^2 sin(x(t)) = 0","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"Here x(t) gives the angular position at time t and θ is  the angular velocity of the linearised pendulum. Under the assumption that the acceleration is in fact a white-noise process, we obtain the Stochastic Differential Equation (SDE)","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":" beginalign\n dd X_t =beginbmatrix 0  1  0  0 endbmatrix X_t dd\n t + beginbmatrix 0  -θ^2 sin(X_1t)endbmatrix dd t +\n  beginbmatrix 0  gamma endbmatrix dd W_t endalign","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"where X_t=beginbmatrix X_t1  X_t2endbmatrix^prime.","category":"page"},{"location":"tutorials/swinging_pendulum/#Defining-diffusion-1","page":"Defining a diffusion process for a swinging pendulum","title":"Defining diffusion","text":"","category":"section"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"To define the diffusion for the pendulum, we use the DiffusionDefinition.jl-package.","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"using Plots, DiffusionDefinition, StaticArrays","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"To avoid typing DiffusionDefinition fully, we define","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"const DD = DiffusionDefinition;","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"To define the diffusion, we specify the dimensions of the state space and Wiener noise and the parameters appearing in the SDE using the diffusion_process-macro. In the call to this macro we specify the dimensions of the state space of the diffusion and driving Wiener process, as also parameters appearing in their definition.","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"@diffusion_process Pendulum begin\n    :dimensions\n    process --> 2\n    wiener --> 1\n\n    :parameters\n    (θ, γ) --> (2, Float64)\nend","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"Note the printed message and that by issuing the command ?Pendulum information on the constructed struct is displayed. Suppose θ=2 and γ=05, then we can define an instance of the struct called Pendulum by setting","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"P = Pendulum(2.0, 0.5)","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"There are various convenience functions, among which","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"DD.parameters(P)\nDD.parameter_names(P)","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"The general form in which the diffusion is specified uses the notation","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":" dd X_t = b(tX_t)dd t + sigma(tX_t) dd W_t","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"So the drift is denoted by b and the diffusivity by σ (this is the notation in the well known books by Rogers and Williams on stochastic calculus). As the functions b and σ are not exported in the DiffusionDefinition-package (to avoid conflicts with other packages), these need to be defined using DiffusionDefinition.b and DiffusionDefinition.σ.","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"DD.b(t, x, P::Pendulum) = @SVector [x[2],-P.θ^2 * sin(x[1])]\nDD.σ(t, x, P::Pendulum) = @SMatrix [0.0 ; P.γ]","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"While not strictly necessary, it is preferable to use static vectors and matrices using commands from the StaticArrays-package.","category":"page"},{"location":"tutorials/swinging_pendulum/#Sampling-trajectories-1","page":"Defining a diffusion process for a swinging pendulum","title":"Sampling trajectories","text":"","category":"section"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"Now we can sample a trajectory of the diffusion. For that, we need a starting point and grid (on which the solution to the SDE is approximated using Euler discretisation).","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"tt = collect(0.0:0.005:8.0)  # grid\nx0 = @SVector [1.0, 0.0]  # starting point\nX = DD.rand(P, tt, x0);","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"Now X is a trajectory, with X.t denoting the timegrid, and X.x the simulated trajectory.","category":"page"},{"location":"tutorials/swinging_pendulum/#Plotting-1","page":"Defining a diffusion process for a swinging pendulum","title":"Plotting","text":"","category":"section"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"Next, we plot the simulated trajectories","category":"page"},{"location":"tutorials/swinging_pendulum/#","page":"Defining a diffusion process for a swinging pendulum","title":"Defining a diffusion process for a swinging pendulum","text":"#using PyPlot\npyplot()\nplot(X, Val(:vs_time))","category":"page"},{"location":"predefined_processes/lotka_volterra/#example_lotka_volterra-1","page":"Lotka-Volterra system","title":"Lotka-Volterra","text":"","category":"section"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"A simple, scalar-valued predator-prey model.","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"beginalign*\ndd X_t = (alpha X_t - beta X_t Y_t) dd t + sigma_1 dd W^(1)_t \ndd Y_t = (delta X_t Y_t -gamma Y_t)dd t + sigma_2 dd W^(2)_t\nendalign*","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"Can be called with","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"@load_diffusion LotkaVolterra","category":"page"},{"location":"predefined_processes/lotka_volterra/#Example-1","page":"Lotka-Volterra system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion LotkaVolterra\nθ = [2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.1, 0.1]\nP = LotkaVolterra(θ...)\ntt, y1 = 0.0:0.001:30.0, @SVector [2.0, 0.25]\nX = rand(P, tt, y1)\nplot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"(Image: lotka_volterra)","category":"page"},{"location":"predefined_processes/lotka_volterra/#Auxiliary-diffusion-1","page":"Lotka-Volterra system","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"We also provide a linear diffusion that is obtained from linearizing SDE above at the equilibrium point. This process can be used as an auxiliary diffusion in the setting of guided proposals. It solves the following stochastic differential equation","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"beginalign*\ndd widetildeX_t = left(- fracbetagammadelta widetildeY_t + fracgammaalphadeltaright) dd t + sigma_1 dd W^(1)_t \ndd widetildeY_t = left(fracalphadeltabeta widetildeX_t-fracalphagammabetaright)dd t + sigma_2 dd W^(2)_t\nendalign*","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"and can be called with","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"@load_diffusion :LotkaVolterraAux","category":"page"},{"location":"predefined_processes/lotka_volterra/#Example-2","page":"Lotka-Volterra system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion LotkaVolterraAux\nθ = [2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.1, 0.1]\nt, T, vT = 0.0, 1.0, nothing # dummy variables\nP = LotkaVolterraAux(θ..., t, T, vT)\ntt, y1 = 0.0:0.001:30.0, @SVector [2.0, 0.25]\nX = rand(P, tt, y1)\nplot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"(Image: lotka_volterra)","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"note: Note\nNote that we had to pass additional variables t, T and vT even though they are immaterial to the auxiliary law. The reason for this is that we defined LotkaVolterraAux in such a way that it is already fully compatible with GuidedProposals.jl and may be passed as an auxiliary law (and auxiliary laws currently require presence of fields t, T and vT). However, in practice, when dealing with LotkaVolterraAux, the internal states of t, T and vT are never used.","category":"page"},{"location":"predefined_processes/lorenz96/#lorenz96_system-1","page":"Lorenz96 system","title":"Lorenz '96 system","text":"","category":"section"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"A model of atmospheric convection where each coordinate of the D-dimensional process X corresponds to a position on a periodic lattice that is supposed to be a proxy for a latitude circle on Earth. The diffusion X is defined as a solution to the following system of SDEs:","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"dd X_t = leftleft(X^(i+1)_t-X^(i-2)_tright)X^(i-1)_t-X^(i)_t+Frightdd t + sigma_i dd W^(i)_tquad tin0Tquad X^(i)_0=x^(i)_0","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"with iin1dotsD a cycling  index. The process can be called with","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"@load_variable_diffusion :Lorenz96 D","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"where D is a positive integer, indicating chosen dimension.","category":"page"},{"location":"predefined_processes/lorenz96/#Example-1","page":"Lorenz96 system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"@load_variable_diffusion Lorenz96 2^10\nθ = [8.0, 1.0]\nP = Lorenz96(θ...)\ntt, y1 = 0.0:0.001:10.0, 9.0.*rand(SVector{2^10,Float64}).-3.0\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), coords=1:10, label=\"\", title=\"first 10 coordinates (out of 1024) vs time\")","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"(Image: lorenz96)","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"tip: Tip\nIf you've done the steps above on your laptop as well, you will have noticed how slow the compilation of the code above took. The reason is that StaticArrays are not designed to work for vectors of size 100+. For this reason it is much better to use in-place versions of samplers. This can be done by changing the default types and then starting from an appropriately changed starting point.const DD = DiffusionDefinition\nDD.default_type(::Lorenz96) = Vector{Float64}\nDD.default_wiener_type(::Lorenz96) = Vector{Float64}\ny1 = 9.0.*rand(2^10).-3.0\nX = rand(P, tt, y1)","category":"page"},{"location":"manual/defining_diffusions/#defining_diffusion-1","page":"Defining diffusions","title":"Defining diffusion","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The main utility macro introduced in this package is @diffusion_process. It facilitates very concise definitions of structs characterizing diffusion processes.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"There are two (optionally three) parts expected by the macro:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"the name of the diffusion (which, optionally, may contain template parameters in the curly brackets)\nand the recipe for defining a struct","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"@diffusion_process NAME{TEMPLATE_PARAMETERS} begin\n  RECIPE\nend","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"the snippet of code above creates a struct named NAME according to specifications listed in the RECIPE.","category":"page"},{"location":"manual/defining_diffusions/#Customization-of-a-struct-1","page":"Defining diffusions","title":"Customization of a struct","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The RECIPE may contain information pertinent to five distinct categories:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Specification of :dimensions\nSpecification of :parameters (their names and datatypes)\nSpecification of :constant_parameters (their names and datatypes)\nSpecification of :auxiliary_info\n:additional information","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Each type needs to be announced to julia by starting the list with the corresponding Symbol (or QuoteNode).","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Note\nFor many users knowing only about :dimensions, :parameters and :additional will be sufficient and the other categories will not be of much importance.","category":"page"},{"location":"manual/defining_diffusions/#Lorenz_example-1","page":"Defining diffusions","title":"Example","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"It's best to look at a simple example. Consider the definition of a Lorenz system:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"@diffusion_process Lorenz{T} begin\n    :dimensions\n    process --> 3\n    wiener --> 3\n\n    :parameters\n    _ --> (3, T)\n    σ --> Float64\n\n    :additional\n    constdiff --> true\n    diagonaldiff --> true\nend","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The macro above expands to:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"mutable struct Lorenz{T} <: DiffusionProcess{Float64, 3, 3, UnboundedStateSpace()}\n    p1::T\n    p2::T\n    p3::T\n    σ::Float64\n    function Lorenz(p1::T, p2::T, p3::T, σ::Float64) where T\n        new{T}(p1, p2, p3, σ)\n    end\n    function Lorenz(; p1::T, p2::T, p3::T, σ::Float64) where T\n        new{T}(p1, p2, p3, σ)\n    end\nend","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"which defines a parametric type Lorenz{T}, together with some handy auxiliary functions specific to any instance of Lorenz{T}. We may now instantiate the newly defined struct as in","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"P_f64 = Lorenz(10.0, 28.0, 8.0/3.0, 0.2)\n# or\nP_f32 = Lorenz(10.0f0, 28.0f0, 8.0f0/3.0f0, 0.2)","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"We can also call some functions that were auto-generated for the newly defined Lorenz struct, for instance","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"DD.parameter_names(Lorenz) == (:p1, :p2, :p3, :σ)\nDD.parameter_names(P_f64) == (:p1, :p2, :p3, :σ)\nDD.parameters(P_f64) == Dict(:p1 => 10.0, :p2 => 28.0, :p3 => 8.0/3.0, :σ => 0.2)","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"More functions are automatically defined in the background for each generated DiffusionProcess, to learn more about them see the list of Utility Functions.","category":"page"},{"location":"manual/defining_diffusions/#Systematic-explanations-1","page":"Defining diffusions","title":"Systematic explanations","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The following information can be specified in the definition of a diffusion law when calling a macro @diffusion_process.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"tip: Tip\nAll keywords read by @diffusion_process are case-insensitive.","category":"page"},{"location":"manual/defining_diffusions/#Category-1:-:dimensions-1","page":"Defining diffusions","title":"Category 1: :dimensions","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Specification of the dimension of the process and the dimension of the driving Brownian motion. Must be written in a format:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"process --> dimension OR\nwiener --> dimension (eg.\nprocess --> 4).","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"In both cases, if left unspecified then defaults to dimension=1.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\n:dimensions is not the only keyword that will be recognized by @diffusion_process as declaring the dimensions of the process. Alternative names that could be used in place of :dimensions are: :dim, :dims, :dimension","category":"page"},{"location":"manual/defining_diffusions/#Category-2:-:parameters-1","page":"Defining diffusions","title":"Category 2: :parameters","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"List of all parameters that the law depends on.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Note\n@diffusion_process understands _ as \"the user doesn't care about the name, so let's use a generic name based on the letter p and append it with a disambiguation number so that if there are more than one p's they are not confused with each other\"","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The parameters must be specified in one of the following formats:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"single-parameter-name --> single-data-type, (eg.\nσ --> Float64 or\nσ --> T (if T is one of the template's labels) or\n_ --> Vector{Int32}).\nThis defines a single parameter.\nsingle-parameter-name --> (multiple-data-types,) (eg.\nσ --> (Float64, Int64),\n_ --> (Int32, T)).\nThis defines as many parameters as there are specified types and appends the names with numbers to disambiguate multiple parameters with the same names.\nsingle-parameter-name --> (number-of-parameters, data-type) (eg.\nσ --> (3, Float64))\ndefines number-of-parameters-many parameters of the same data type.\n(multiple-parameter-names,) --> single-data-type (eg.\n(α, β, γ) --> Int64)\ndefines as many parameters as there are names specified and sets them to be of the same type.\n(multiple-parameter-names,) --> (multiple-data-types,) (eg.\n(α, β, γ) --> (Float64, Int64, T))\ndefines as many parameters as there are names specified (there should be an equal number of names as there are types, it will throw an AssertionError otherwise) and sets them to be of the corresponding type.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\n:parameters keyword alternatives: :param, :params","category":"page"},{"location":"manual/defining_diffusions/#Category-3:-:constant_parameters-1","page":"Defining diffusions","title":"Category 3: :constant_parameters","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"These can be defined in exactly the same way as :parameters. The only purpose for splitting the parameters into :constant_parameters and :parameters is to indicate to Julia that the set of all parameters may be split into two conceptually different groups. In particular, @diffusion_process defines utility functions that act differently with :constant_parameters and :parameters:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"DiffusionDefinition.parameters\nDiffusionDefinition.const_parameters\nDiffusionDefinition.var_parameters\nDiffusionDefinition.parameter_names\nDiffusionDefinition.const_parameter_names\nDiffusionDefinition.var_parameter_names","category":"page"},{"location":"manual/defining_diffusions/#DiffusionDefinition.parameters","page":"Defining diffusions","title":"DiffusionDefinition.parameters","text":"parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.const_parameters","page":"Defining diffusions","title":"DiffusionDefinition.const_parameters","text":"const_parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value. Return only those parameteres that are considered to be constant.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.var_parameters","page":"Defining diffusions","title":"DiffusionDefinition.var_parameters","text":"var_parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value. Return only those parameteres that are considered to be variable.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.parameter_names","page":"Defining diffusions","title":"DiffusionDefinition.parameter_names","text":"parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters.\n\n\n\n\n\nparameter_names(::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.const_parameter_names","page":"Defining diffusions","title":"DiffusionDefinition.const_parameter_names","text":"const_parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters that are considered to be constant.\n\n\n\n\n\nconst_parameter_names(P::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters that are considered to be constant.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.var_parameter_names","page":"Defining diffusions","title":"DiffusionDefinition.var_parameter_names","text":"var_parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters that are considered to be variable.\n\n\n\n\n\nvar_parameter_names(P::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters that are considered to be variable.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Note\nThe split into constant and variable parameters is not done at a compile time and can also be done by hand after the struct with the diffusion has been constructed. For instance, in the Lorenz example above we have:julia> DD.parameters(P_f64)\nDict{Symbol,Float64} with 4 entries:\n  :p2 => 28.0\n  :σ  => 0.2\n  :p1 => 10.0\n  :p3 => 2.66667\n\njulia> DD.const_parameters(P_f64)\nDict{Any,Any} with 0 entries\n\njulia> DD.var_parameters(P_f64)\nDict{Symbol,Float64} with 4 entries:\n  :p2 => 28.0\n  :σ  => 0.2\n  :p1 => 10.0\n  :p3 => 2.66667If we wanted to change our mind and define, say, :p1 and :p3 as constant parameters we could do that by overwriting the definition of the const_parameter_names(::Type{<:CustomDiffusionLaw}) method, as all other functions of this type are computed as a byproduct of parameter_names(::Type{<:CustomDiffusionLaw}) and const_parameter_names(::Type{<:CustomDiffusionLaw}) and the former one should never change.DD.const_parameter_names(::Type{<:Lorenz}) = (:p1, :p3)That's all that needs to be changed.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\n:constant_parameters keyword alternatives: const_parameters, :const_param, :const_params, :constparameters, :constparam, :constparams, :constant_param, :constant_params, :constantparameters, :constantparam, and :constantparams.","category":"page"},{"location":"manual/defining_diffusions/#Category-4:-:auxiliary_info-1","page":"Defining diffusions","title":"Category 4: :auxiliary_info","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Information about the end-points of the diffusion. This is a useful feature for guided proposals or simulation of diffusion bridges, where the process is conditioned to hit a certain end-point. In particular, it is used quite extensively in the package GuidedProposals.jl. The following fields can be defined:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"t0 (also accepts :t_0): the starting time-point\nT: the final time-point\nv0 (also accepts :obs0, :v_0, :obs_0): the starting observation\nvT (also accepts :obsT, :v_T, :obs_T): the observation at the terminal time","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Each one of these fields can be defined in a format field-name --> field-type (e.g. T --> Float64).","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\nauxiliary_info keyword alternatives: :aux_info, :end_points, :end_point_info","category":"page"},{"location":"manual/defining_diffusions/#Category-5:-:additional-1","page":"Defining diffusions","title":"Category 5: :additional","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The additional information provides some additional decorators that helps the compiler use specialized functions when called on instances of corresponding diffusion processes. The following information can be specified","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"constdiff --> true (or false) depending on whether the volatility coefficient is independent from the state variable (false by default).\nAlternative keywords: :constvola, :constdiffusivity, :constvolatility, :constσ, :constantdiff, :constantvola, :constantdiffusivity, :constantvolatility, :constantσ.\ndiagonaldiff --> true (or false) to indicate that the volatility coefficient is represented by a diagonal matrix (false by default).\nAlternative keywords: :diagonalvola, :diagonaldiffusivity, :diagonalvolatility, :diagonalσ, :diagdiff, :diagvola, :diagdiffusivity, :diagvolatility, :diagσ.\nsparsediff --> true (or false) to indicate that the volatility coefficient is a represented by a sparse matrix (false by default).\nAlternative keywords: :sparsevola, :sparsediffusivity, :sparsevolatility, :sparseσ.\nlinear --> true (or false) to indicate that a diffusion has a linear structure (false by default).\ndiagonalbmat --> true (or false) to indicate that a B matrix of a linear diffusion (with a drift b(x):=Bx+β) is diagonal (false by default).\nAlternative keywords: :diagonalb, :diagonalbmatrix.\nsparsebmat --> true (or false) to indicate that a B matrix of a linear diffusion (with a drift b(x):=Bx+β) is sparse (false by default).\nAlternative keywords: :sparseb, :sparsebmatrix.\nstatespace --> type-of-state-space-restrictions (eg. statespace --> UnboundedStateSpace()) indicates any restrictions made on the state-space of a diffusion process.\neltype --> type-of-parameter (eg. eltype --> Float64) disambiguate the parameter type in case multiple types are used. This is useful for automatic differentiation where the derivatives of only a subset of parameters are taken and it is the eltype of those parameters that is of interest. [TODO come back, not sure anymore if it has any use]","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\n:additional keyword alternatives: :extra","category":"page"},{"location":"manual/defining_diffusions/#Additional-functions-1","page":"Defining diffusions","title":"Additional functions","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"For each struct defining a diffusion law we may define some additional functions that are not automatically generated by the @diffusion_process macro. These additional functions can provide us with some extra functionality implemented in other packages of the JuliaDiffusionBayes suite.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"There are two groups of extra functions","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Functions that are needed for the conjugate updates from the package DiffusionMCMC.jl. They are discussed in detail here.\nFunctions needed for blocking, that can be implemented for instance with the package GuidedProposals.jl or DiffusionMCMC.jl. These need to be overwritten only if your diffusion is hypoelliptic, otherwise the defaults will work just fine. The first one is a function nonhypo, with the documentation that can be found here. It can be overwritten directly, or can be defined automatically when defining conjugate updates. The second function is","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"DiffusionDefinition.nonhypo_σ","category":"page"},{"location":"manual/defining_diffusions/#DiffusionDefinition.nonhypo_σ","page":"Defining diffusions","title":"DiffusionDefinition.nonhypo_σ","text":"nonhypo_σ((t,i)::IndexedTime, x, P::DiffusionProcess)\n\nReturn a sub-matrix of the full volatility matrix σ that consists of non-zero rows of σ.\n\n\n\n\n\nnonhypo_σ(t::Float64, x, P)\n\nReturn a sub-matrix of the full volatility matrix σ that consists of non-zero rows of σ.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"tip: Tip\nThe functions from the latter group are not discussed any further in this documentation. Please see the tutorial on blocking from GuidedProposals.jl to learn more.","category":"page"},{"location":"manual/conjugate_updates/#conjugate_updates-1","page":"Conjugate updates","title":"Conjugate updates","text":"","category":"section"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"In an MCMC setting it is sometimes possible to employ certain types of efficient updates called \"conjugate updates\". They can be employed if the likelihood and the prior fit together like a glove, allowing to pin down the posterior density by identifying it with one of the standard distributions. For the parameters appearing in the diffusion's drift such prior–posterior pair can sometimes be taken to be Gaussian–Gaussian.","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"This package does not deal with MCMC sampling for diffusions; however, it defines macros that automatically build functions that are required for conjugate updates in DiffusionMCMC.jl. Below, we explain only how the macros introduced in DiffusionDefinition.jl work and give no further details about conjugate updates. To see more details about on this topic see [...].","category":"page"},{"location":"manual/conjugate_updates/#conjugate_gaussian_updates-1","page":"Conjugate updates","title":"Conjugate Gausian updates","text":"","category":"section"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"To perform conjugate Gaussian updates in DiffusionMCMC.jl the following functions need to be defines for your diffusion law:","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"DiffusionDefinition.phi\nDiffusionDefinition.num_non_hypo\nDiffusionDefinition.hypo_a_inv\nDiffusionDefinition.nonhypo\nDiffusionDefinition.ignore_for_cu","category":"page"},{"location":"manual/conjugate_updates/#DiffusionDefinition.phi","page":"Conjugate updates","title":"DiffusionDefinition.phi","text":"phi(::Val{T}, t, x, P) where T\n\nIf the drift can be written in a form:\n\nb_θ(t x) = θ^Tφ(tx)+ϕ(tx)\n\nfor parameters θ that are being updated, then phi is a row of the matrix φ(tx) that get's multiplied by the coordinate of a θ vector with a name T.\n\n\n\n\n\n","category":"function"},{"location":"manual/conjugate_updates/#DiffusionDefinition.num_non_hypo","page":"Conjugate updates","title":"DiffusionDefinition.num_non_hypo","text":"num_non_hypo(Ptype::Type{T}) where T <: DiffusionProcess\n\nReturn a total number of coordinates of the diffusion process that have non-degenerate noise structure. I.e. it is equal to the total number of coordinates of the process minus the number of coordinates that have no direct Wiener contribution.\n\n\n\n\n\n","category":"function"},{"location":"manual/conjugate_updates/#DiffusionDefinition.hypo_a_inv","page":"Conjugate updates","title":"DiffusionDefinition.hypo_a_inv","text":"hypo_a_inv(t, x, P)\n\nSimilar to a^-1=(σσ^T)^-1, with the only exception that all of the zero rows of σ are first removed to yield hatσ, and then, (hatσ hatσ^T)^-1 is computed.\n\n\n\n\n\n","category":"function"},{"location":"manual/conjugate_updates/#DiffusionDefinition.nonhypo","page":"Conjugate updates","title":"DiffusionDefinition.nonhypo","text":"nonhypo(x, P)\n\nReturn the diffusion's coordinates that have direct contribution from some non-degenerate Wiener terms, i.e. leave out coordinates whose Wiener term is zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/conjugate_updates/#DiffusionDefinition.ignore_for_cu","page":"Conjugate updates","title":"DiffusionDefinition.ignore_for_cu","text":"ignore_for_cu(::Val{T}, P) where T\n\nA flag to indicate that a parameter with name T has no contribution to the computation of conjugate updates.\n\n\n\n\n\n","category":"function"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"In this package we implement a macro that makes this definition process more convenient","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"DiffusionDefinition.@conjugate_gaussian","category":"page"},{"location":"manual/conjugate_updates/#DiffusionDefinition.@conjugate_gaussian","page":"Conjugate updates","title":"DiffusionDefinition.@conjugate_gaussian","text":"@conjugate_gaussian DIFFUSION_NAME begin\n    BODY\nend\n\nDefine helper functions for the conjugate gaussian updates of diffusion DIFFUSION_NAME. In BODY information can be passed as a list with elements of the form:\n\n:entry-name --> entry-value\n\nThe following entry names have special meaning: :inplace, :nonhypo, :hypo_a_inv. Any other name is interpreted as a parameter name for which function phi is defined. More precisely, the following can be defined:\n\n:inplace\n\n:inplace --> true\n\nto indicate that compmutations are to be done in-place. Otherwise, by default they are assumed to be done out-of-place.\n\n:nonhypo\n\n:nonhypo --> list-of-indices-with-non-degenerate-noise\n\ne.g.\n\n:nonhypo --> [1,3,5]\n\nto indicate which coordinates have non-degenerate (i.e. non-zero) Wiener term Wiener term. It automatically defines num_non_hypo for the user.\n\nwarning: Warning\nIf no flag :inplace --> true is passed, then it will be assumed that computations are done out-of-place by default and then no matter what subset you passed it will be internally saved as an SVector so as to work as a static way of accessing a subset of parameters. Otherwise, no change will be made to list-of-indices-with-non-degenerate-noise.\n\nhypo_a_inv\n\n:hypo_a_inv --> f(t,x,P)\n\nwhere f is a function that uses time variable t, state variable x and a struct with the target diffusion law P.\n\nphi and ignore_for_cu\n\n:name-of-parameter --> (φ₁(t,x,P), φ₂(t,x,P), ...)\n\nwhere φ₁(t,x,P) corresponds to all terms from the drift that are in the first non-degenerate coordinate and that are multiplied by the parameter with the name name-of-parameter, etc. Any parameters of P for which φ is not defined will have a function ignore_for_cu defined for them automatically and returning true.\n\n\n\n\n\n","category":"macro"},{"location":"manual/conjugate_updates/#Example-1","page":"Conjugate updates","title":"Example","text":"","category":"section"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"For instance, for the FitzHugh–Nagumo model in the conjugate-parameterization form from here, we can define functions for the conjugate updates as follows:","category":"page"},{"location":"manual/conjugate_updates/#","page":"Conjugate updates","title":"Conjugate updates","text":"@conjugate_gaussian FitzHughNagumoConjug begin\n    :intercept --> (-x[2],)\n    :ϵ --> (x[1]-x[1]^3+(1-3*x[1]^2)*x[2],)\n    :s --> (one(x[1]),)\n    :γ --> (-x[1],)\n    :β --> (-one(x[1]),)\n    :hypo_a_inv --> 1.0/P.σ^2\n    :nonhypo --> 2:2\nend","category":"page"},{"location":"get_started/package_overview/#get_started-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl","category":"page"},{"location":"get_started/package_overview/#Defining-the-process-1","page":"Get started","title":"Defining the process","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"To define a diffusion law use a macro @diffusion_process:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"using DiffusionDefinition\nconst DD = DiffusionDefinition\n\n@diffusion_process OrnsteinUhlenbeck begin\n    # :dimensions is optional, defaults both process and wiener to 1 anyway\n    :dimensions\n    process --> 1\n    wiener --> 1\n\n    :parameters\n    (θ, μ, σ) --> Float64\nend","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"This will define a struct OrnsteinUhlenbeck and announce to Julia that it represents a one-dimensional diffusion process driven by a one-dimensional Brownian motion and that it depends on 3 parameters of type Float64 each.","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"To complete characterization of a diffusion law we define the drift and diffusion coefficients:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"DD.b(t, x, P::OrnsteinUhlenbeck) = P.θ*(P.μ - x)\nDD.σ(t, x, P::OrnsteinUhlenbeck) = P.σ","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"We will also specify a default datatype for convenient definition of trajectories","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"DD.default_type(::OrnsteinUhlenbeck) = Float64\nDD.default_wiener_type(::OrnsteinUhlenbeck) = Float64","category":"page"},{"location":"get_started/package_overview/#Sampling-trajectories-under-the-diffusion-law-1","page":"Get started","title":"Sampling trajectories under the diffusion law","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"Use the function rand to sample the process","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"tt, x0 = 0.0:0.01:100.0, 0.0\nP = OrnsteinUhlenbeck(2.0, 0.0, 0.1)\nX = rand(P, tt, x0)","category":"page"},{"location":"get_started/package_overview/#Plotting-the-trajectories-1","page":"Get started","title":"Plotting the trajectories","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"Plotting may be done with any supported backend via function plot. Plotting recipes are provided which make sure that the output of rand (of the datatype trajectory) is understood by plot. For instance, to plot all diffusion coordinates (in case above only one) against the time variable write","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"using Plots\ngr()\nplot(X, Val(:vs_time))","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"(Image: ou_process)","category":"page"},{"location":"get_started/package_overview/#Repeated-sampling-1","page":"Get started","title":"Repeated sampling","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"The package is implemented with the setting of Markov chain Monte Carlo methods in mind. Consequently, methods are built to be as efficient as possible under the setting of repeated sampling of trajectories. To fully leverage this speed you need to pre-allocate the containers for trajectories:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"X, W = trajectory(tt, P)","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"and then sample the process by:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"drawing the driving Brownian motion W,\nand then, solve!ing the path X from the Wiener path W","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"Wnr = Wiener()\nrand!(Wnr, W)\nDD.solve!(X, W, P, x0)","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"Sampling trajectories multiple times becomes very efficient then, for instance:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"julia> function foo(Wnr, W, X, P, x0)\n           for _ in 1:10^4\n               rand!(Wnr, W)\n               DD.solve!(X, W, P, x0)\n           end\n       end\nfoo (generic function with 1 method)\njulia> using BenchmarkTools\njulia> foo($Wnr, $W, $X, $P, $x0)\n  1.840 s (0 allocations: 0 bytes)","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"i.e. 2 seconds to sample 10 000 trajectories, each revealed on a time-grid with 10 001 points (tested on an Intel(R) Core(TM) i7-4600U CPU @ 2.10GHz).","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#FitzHugh-Nagumo-model-1","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A model developed to mimic the evolution of a neuron's membrane potential. Originally, it has been developed as a modification to the Van der Pol oscillator.","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Three parametrisations of the process are provided in this package.","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Regular-1","page":"FitzHugh-Nagumo model","title":"Regular","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Defined simply as FitzHughNagumo is a solution (Y,X) to the following stochastic differential equation:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = frac1epsilonleft( Y_t - Y_t^3-X_t + s right )dd t\ndd X_t = left( gamma Y_t - X_t + beta right )dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumo","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Example-1","page":"FitzHugh-Nagumo model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.001:30.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), size=(800, 300))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_vs_time)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"plot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_x_vs_y)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Alternative-1","page":"FitzHugh-Nagumo model","title":"Alternative","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The stochastic differential equation above is re-parametrized in such a way that the first coordinate is given by the integrated second coordinate:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = dotY_t dd t\ndddotY_t = frac1epsilonleft( (1-gamma)Y_t -Y_t^3 -epsilon dotY_t + s - beta + left( 1-3Y_t^2 right)dotY_t right)dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The process (with name FitzHughNagumoAlt) can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAlt","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Example-2","page":"FitzHugh-Nagumo model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A parameterization equivalent to the above is then given by:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion FitzHughNagumoAlt\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumoAlt(θ...)\ntt, y1 = 0.0:0.001:30.0, @SVector [-0.9, 0.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), size=(800, 300))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_vs_time)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"plot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_x_vs_y)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#conjugate_fitzhugh_nagumo-1","page":"FitzHugh-Nagumo model","title":"Conjugate","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to alternative parametrisation above, the only difference being that an additional step is taken of redefining the parameters:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"sleftarrow fracsepsilonquad betaleftarrowfracbetaepsilonquad sigmaleftarrowfracsigmaepsilonquad gammaleftarrowfracgammaepsilonquad epsilonleftarrowfrac1epsilon","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"This results in the stochastic differential equation of the form:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = dotY_t dd t\ndddotY_t = left( (epsilon-gamma)Y_t -epsilon Y_t^3 -dotY_t + s - beta + epsilonleft( 1-3Y_t^2 right)dotY_t right)dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The diffusion (with a struct name FitzHughNagumoConjug) can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjug","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Example-3","page":"FitzHugh-Nagumo model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A parameterization equivalent to the above is then given by:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion FitzHughNagumoConjug\nθ = [10.0, -8.0, 15.0, 0.0, 3.0]\nP = FitzHughNagumoConjug(θ...)\ntt, y1 = 0.0:0.001:30.0, @SVector [-0.7, 0.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), size=(800, 300))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_vs_time)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"plot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_x_vs_y)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Auxiliary-diffusions-(TODO-the-code-won't-execute-correctly)-1","page":"FitzHugh-Nagumo model","title":"Auxiliary diffusions (TODO the code won't execute correctly)","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Additionally, we defined linear diffusions that can be taken as auxiliary processes in the setting of Guided proposals. For all of these definitions it is assumed that the target process is observed completely at discrete times. For other observation settings the auxiliary diffusions need to be defined by the user, but the definitions in this package may act as a guide on how to do it.","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#For-regular-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For regular parametrisation","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A linear diffusion obtained by linearising regular definition of the FitzHugh-Nagumo diffusion at an end-point:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd widetildeY_t = frac1epsilonleft( left( 1-3y_T^2 right )widetildeY_t - widetildeX_t + s + 2y_T^3 right)dd t\nddwidetildeX_t = left( gamma widetildeY_t - widetildeX_t + beta right)dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAux","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#For-alternative-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For alternative parametrisation","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#Simple-1","page":"FitzHugh-Nagumo model","title":"Simple","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A pair: (I,B), where B is a scaled Brownian motion and I is an integrated B:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd I_t = B_tdd t\ndd B_t = fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAltAuxSimple","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Linearisation-at-the-end-point-1","page":"FitzHugh-Nagumo model","title":"Linearisation at the end-point","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A linear diffusion obtained by linearising alternative definition of the FitzHugh-Nagumo diffusion at an end-point. If only the first coordinate is observed the proposal takes a form:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 right )widetildeY_t +left( 1-epsilon-3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta right )right dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"On the other hand, if both coordinates are observed, the proposal is given by:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 - 6y_Tdoty_T right )widetildeY_t +left( 1-epsilon -3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta + 6y_T^2doty_T right )right dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAltAuxLin","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#For-conjugate-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For conjugate parametrisation","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#Simple-2","page":"FitzHugh-Nagumo model","title":"Simple","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A pair: (I,B), where B is a scaled Brownian motion and I is an integrated B:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd I_t = B_tdd t\ndd B_t = sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjugAuxSimple","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Linearisation-at-the-end-point-2","page":"FitzHugh-Nagumo model","title":"Linearisation at the end-point","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to FitzHughNagumoAltAuxLin, the only difference being that an additional step is taken of redefining the parameters (just as it was done in FitzHughNagumoConjug above). Consequently it is the solution to:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = left left epsilonleft(1-3y_T^2 - 6y_Tdoty_T right )-gamma right widetildeY_t +left epsilonleft( 1-3y_T^2 right)-1 right widetildeX_t + leftepsilonleft(2y_T^3+ 6y_T^2doty_T right ) +s-beta rightright dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"and can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjugAuxLin","category":"page"},{"location":"manual/reparameterization/#Reparameterizations-1","page":"Reparameterizations","title":"Reparameterizations","text":"","category":"section"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"","category":"page"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"Instances of DiffusionProcess are mutable so their fields may be changed directly. We provide additional convenience functions for reparameterizations. The first one clones the object and creates a new one with new parameters:","category":"page"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"DiffusionDefinition.clone","category":"page"},{"location":"manual/reparameterization/#DiffusionDefinition.clone","page":"Reparameterizations","title":"DiffusionDefinition.clone","text":"clone(P::T, θ::AbstractDict) where T <: DiffusionProcess\n\nSimplified cloning of diffusion law P. Substitute relevant parameters with new values. θ must be a dict corresponding to parameters returned after a call to var_parameters.\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"However, it's not recommended to rely on it and it will become deprecated in the near future.","category":"page"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"A more efficient function, suitable for the MCMC setting is:","category":"page"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"DiffusionDefinition.set_parameters!","category":"page"},{"location":"manual/reparameterization/#DiffusionDefinition.set_parameters!","page":"Reparameterizations","title":"DiffusionDefinition.set_parameters!","text":"set_parameters!(P::DiffusionProcess, θ, entries)\n\nSet parameters of a diffusion law P in-place. entries should be a collection of pairs Pair{Int64,Symbol} that list the relevant entries in θ for reparameterization, together with the corresponding parameter names.\n\n\n\n\n\n","category":"function"},{"location":"manual/load_diff/#Loading-diffusions-1","page":"Loading diffusions","title":"Loading diffusions","text":"","category":"section"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"Many standard diffusion processes have already been defined by us in this package via @diffusion_process and you may simply load them and start using them immediately without having to define them yourself. To see a list of all available processes call","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"@load_diffusion","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"See the Predefined processes for more detailed descriptions. To load a particular diffusion simply write: @load_diffusion DiffusionName. For instance:","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"@load_diffusion LotkaVolterraAux","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"Then the process can be instantiated:","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"α, β, γ, δ, σ1, σ2 = 2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.2, 0.3\nlotka_volterra = LotkaVolterraAux(\n    α, β, γ, δ, σ1, σ2,\n    0.0, 1.0, zero(DD.ℝ{2}), zero(DD.ℝ{2})\n)","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"A very small subgroup of predefined diffusions have a variable dimension parameter. For these we provide a @load_variable_diffusion macro, that in addition to a diffusion name accepts also a dimension of the process and dimension of the wiener process. For instance","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"@load_variable_diffusion Lorenz96 2^10\n# if it made sense an additional 2nd number would specify the dimension of a Wiener process","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#How-to-customize-plots-of-diffusion-trajectories?-1","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"","category":"section"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"Underneath a call to","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"X = ... # sampled trajectory\nplot(X, Val(:x_vs_y))\n# or\nplot(X, Val(:vs_time))","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"Julia looks up the relevant plotting recipes implemented in DiffusionDefinition.jl in order to understand how the plot function should handle the object","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"X::Trajectory","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"However, in any other capacity, the called plot function behaves in an exactly the same way as if arrays with data were passed for plotting. In particular, you can pass additional named arguments as you would to a regular call to a plot function and change the plotting backend to anything supported by Julia.","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#Example-1","page":"How to customize plots of diffusion trajectories?","title":"Example","text":"","category":"section"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"For instance, using the law of the Lorenz–63 system we can decorate our plots as follows:","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"# change the backend if you want to\ngr()\n\n# plot\nplot(\n    X, Val(:vs_time);\n    layout=(3, 1),\n    size=(500, 800),\n    label=[\"X₁\" \"X₂\" \"X₃\"],\n    color=[\"blue\" \"red\" \"green\"],\n    linewidth=[1 2 3]\n)","category":"page"},{"location":"how_to_guides/customize_my_diffusion_plots/#","page":"How to customize plots of diffusion trajectories?","title":"How to customize plots of diffusion trajectories?","text":"(Image: lorenz63)","category":"page"},{"location":"manual/buffers/#explain_buffers-1","page":"Buffers","title":"Buffers","text":"","category":"section"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"","category":"page"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"Buffers are simply structs gathering containers that are used for in-place computations. They inherit from","category":"page"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"DiffusionDefinition.AbstractBuffer","category":"page"},{"location":"manual/buffers/#DiffusionDefinition.AbstractBuffer","page":"Buffers","title":"DiffusionDefinition.AbstractBuffer","text":"AbstractBuffer{T} <: AbstractArray{T,1}\n\nTypes inheriting from AbstractBuffer define buffers used for various in-place computations.\n\n\n\n\n\n","category":"type"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"and don't require any special methods, except for functions b! and σ! (or for linear diffusions B! and β! in place of b!) having to specify explicitly how the drift and volatility are supposed to be saved inside the buffers. We provide implementation of standard buffers that should be sufficient for many problems:","category":"page"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"DiffusionDefinition.StandardEulerBuffer\nDiffusionDefinition.LinearDiffBuffer","category":"page"},{"location":"manual/buffers/#DiffusionDefinition.StandardEulerBuffer","page":"Buffers","title":"DiffusionDefinition.StandardEulerBuffer","text":"struct StandardEulerBuffer{Tb,Tσ,Tdw} <: AbstractBuffer\n    b::Tb\n    y::Tb\n    σ::Tσ\n    dW::Tdw\nend\n\nStandard buffer for the Euler-Maruyama simulations. The intermediary data is stored in b, σ, y and dW.\n\n\n\n\n\n","category":"type"},{"location":"manual/buffers/#DiffusionDefinition.LinearDiffBuffer","page":"Buffers","title":"DiffusionDefinition.LinearDiffBuffer","text":"struct LinearDiffBuffer{Tb,Tσ,Tdw,TB} <: AbstractBuffer\n    b::Tb\n    y::Tb\n    σ::Tσ\n    dW::Tdw\n    B::TB\nend\n\nA buffer for Euler-Maruyama simulations of linear diffusions. Almost the same as StandardEulerBuffer, but contains additional space for an intermediate construction of a matrix B.\n\n\n\n\n\n","category":"type"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"tip: Tip\nIf you call in-place methods multiple times, then make sure to pre-define a buffer and then pass it explicitly to solve!.","category":"page"},{"location":"tutorials/diffusion_bridges/#tutorial_sampling_diff_bridges-1","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"In this tutorial we will illustrate how to sample diffusion bridges using rejection sampling and importance sampling with Brownian bridge proposals. We will also embed the latter routine in a Metropolis–Hastings algorithm. We will illustrate the techniques on the example of a bivariate double-well potential.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"warning: Warning\nSampling of diffusion bridges using rejection sampling or importance sampling with Brownian bridge proposals is—in general—not an efficient method and for plenitude of problems it is not even applicable. It is, however, an excellent starting point for learning about simulation of conditioned diffusions. The tutorial is meant as a didactic explanation of the common mechanisms behind most samplers of conditioned diffusions. Nevertheless, it is NOT meant to be used for production purposes. For that we refer the user to GuidedProposals.jl, which has been designed to specifically address the problem of sampling conditioned diffusions.","category":"page"},{"location":"tutorials/diffusion_bridges/#Why-is-there-so-much-text-in-this-tutorial?-1","page":"Sampling of diffusion bridges","title":"Why is there so much text in this tutorial?","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Sampling of diffusion bridges might seem like an innocent problem if you haven't seen it before. It is however a considerable obstacle that many mathematicians, statisticians and physicists have been attacking for tens of years. And for good reasons—efficient methods that solve this problem are considered to be extremely valuable tools for a variety of real-world applications. No universal solution has been found, however, there are a few contending methodologies that perform particularly well across a variety of problems of this kind. Many of those techniques are far too complicated to be explained in a single tutorial. Fortunately, simple versions of rejection and importance sampling fit the bill just right. Even these however require from us to cover some additional details. Hence the length of the tutorial.","category":"page"},{"location":"tutorials/diffusion_bridges/#Rejection-sampling-1","page":"Sampling of diffusion bridges","title":"Rejection sampling","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Rejection sampling is a simple, but extremely powerful technique for obtaining independent samples from some probability law mathbbP (with density dd mathbbP) using independent samples from another probability law mathbbQ (with density dd mathbbQ). You may, for instance, check out the wikipedia article to learn more.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"The basic algorithm is as follows:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"struct RejectionSampling end\n# these need to be appropriately defined\nfunction density(P, at=x) ... end\nfunction some_max_bound_on_dP_over_dQ(P, Q) ... end\nP, Q = ...\n\nfunction Base.rand(P, Q, ::RejectionSampling)\n    M = some_max_bound_on_dP_over_dQ(P, Q)\n    while true\n        X° = rand(Q) # proposal\n        acceptance_prob = density(P, at=X) / (density(Q, at=X) * M)\n        # accept/reject; if reject then re-sample and retry; if accept then return X°\n        if rand() <= acceptance_prob\n            return X°\n        end\n    end\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"A sample returned by the algorithm above:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"X = rand(P, Q, RejectionSampling())","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"is distributed exactly according to mathbbP even though all sampling was done exclusively through the law mathbbQ.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"tip: Definition\nThe law mathbbP is called the target law, whereas mathbbQ is called the proposal law.","category":"page"},{"location":"tutorials/diffusion_bridges/#Rejection-sampling-on-a-path-space-1","page":"Sampling of diffusion bridges","title":"Rejection sampling on a path space","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Rejection sampling on a path space is a fancy name for the algorithm above as applied to diffusion processes, i.e. when the laws mathbbP and mathbbQ are some diffusion laws.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Computation of each individual term in the acceptance probability","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"acceptance_prob = density(P, at=X) / (density(Q, at=X) * M)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"which in a mathematical notation becomes:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"beginequationlabeleqaccpprobrs\nfrac1Mfracdd mathbbPdd mathbbQ(X)\nendequation","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"is not possible when working with diffusion processes. Nevertheless, the overall term can sometimes be found.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"note: Some mathematical details\nIn particular, let's assume that the target diffusion law is of the following form:beginequationlabeleqtarget_rejection\ndd X_t = α(X_t)dd t + dd W_tquad X_0=x_0 quad tin0T\nendequationwith αRR^dRR^d (at least once continuously differentiable), a volatility coefficient given by the identity matrix and W denoting a d-dimensional Brownian motion. Additionally, let's assume that there exists a function ARR^dRR such that:A(x) = α(x)(We refer to A as a potential function). Then, if we let mathbbP denote the law of \\eqref{eq:target_rejection} conditioned on an end-point, i.e. of:dd X_t = α(X_t)dd t + dd W_tquad X_0=x_0quad X_T=x_T quad tin0Tand we let mathbbQ denote the law of a d–dimensional Brownian bridge joining x_0 and x_T on 0T, then the Radon–Nikodym derivative between the two is proportional to:beginequationlabeleqrnd\nfracdd mathbbPdd mathbbQ(X)propto expleft- int_0^Tϕ(X_t)dd t rightleq 1\nendequationwherebeginequationlabeleqphi_function\nphi(x)=frac12left alphaalpha + Δ A right(x) - l\nendequationand l is any constant, which we may take in particular to belleq inf_xinRR^dleft frac12left alphaalpha + Δ A right(x) rightthat guarantee the inequality leq 1 in \\eqref{eq:rnd} and where the infimum on the right is assumed to exist (if it does not, then rejection sampling with Brownian bridge proposals cannot be applied).","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"The main take-away message from the box above is that if the stochastic differential equation admits a nice enough expression \\eqref{eq:target_rejection}, then it is possible to find a closed form formula for the computation of the acceptance probability","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"frac1Mfracdd mathbbPdd mathbbQ(X)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"and rejection sampling on a path space can be performed by simply repeatedly drawing from mathbbQ–the law of Brownian bridges (see this how-to-guide for more info)—and accepting the samples with probability given in \\eqref{eq:rnd}.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"note: Lamperti transformation\nThe restriction to identity matrix volatility coefficient may be slightly relaxed thanks to existence of Lamperti transformation, which allows one to transform a diffusion with a non-identity volatility coefficient to the one with identity volatility. This transform is applicable to all scalar diffusions, however, in multiple dimensions it is more restrictive. See [Ait Sahalia 2008] for more details.","category":"page"},{"location":"tutorials/diffusion_bridges/#Example-1","page":"Sampling of diffusion bridges","title":"Example","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Let's look at a simple example of a bivariate double-well potential model solving the following SDE","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"dd X_t = -frac12A(X_t)dd t + dd W_tquad X_0 = x_0quad tin0T","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"where","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"A(x) = ρ_1left (x_2)^2 - μ_1 right^2 + ρ_2left x_2 - μ_2 x_1 right^2","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"and ρ_1ρ_2μ_1μ_20 are parameters. We can define it very simply","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"using DiffusionDefinition\nconst DD = DiffusionDefinition\n\nusing StaticArrays, LinearAlgebra\n\n@diffusion_process BivariateDoubleWell{T} begin\n    :dimensions\n    process --> 2\n    wiener --> 2\n\n    :parameters\n    (ρ1, ρ2, μ1, μ2) --> T\n\n    :additional\n    constdiff --> true\nend\n\nDD.b(t, x, P::BivariateDoubleWell) = @SVector [\n    P.μ2*P.ρ2*(x[2]-P.μ2*x[1]),\n    2.0*P.ρ1*P.μ1*x[2] - 2.0*P.ρ1*x[2]^3 - P.ρ2*(x[2]-P.μ2*x[1]),\n]\n\n@inline DD.σ(t, x, P::BivariateDoubleWell) = SDiagonal{2,Float64}(I)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"note: Note\nIn fact, below, we will never use the volatility coefficient. We defined it simply for completeness.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Tedious calculations reveal that function ϕ achieves a global minimum:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"inf_xϕ(x)= -fracp_1+p_254μ_2^2(1+μ_2^2)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"where","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"beginalign*\np_1=2μ_2sqrt2ρ_1left 9 + μ_2^2left(9+2ρ_1μ_1^2right) right^32\np_2=μ_2^2left 54ρ_1μ_1(1+μ_2^2) - 8ρ_1^2μ_1^3μ_2^2 + 27ρ_2(1+μ_2^2)^2 right\nendalign*","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"In Julia this becomes","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"function inf_ϕ(P::BivariateDoubleWell)\n    -( compute_p1(P) + compute_p2(P) )/( 54.0*P.μ2^2*(1.0 + P.μ2^2) )\nend\n\nfunction compute_p1(P::BivariateDoubleWell)\n    2.0*P.μ2*sqrt(2.0*P.ρ1)*(\n        9.0 + P.μ2^2*(9.0 + 2.0*P.ρ1*P.μ1^2)\n    )^(3/2)\nend\n\nfunction compute_p2(P::BivariateDoubleWell)\n    P.μ2^2*(\n        54.0*P.ρ1*P.μ1*(1.0+P.μ2^2)\n        - 8.0*P.ρ1^2*P.μ1^3*P.μ2^2\n        + 27*P.ρ2*(1.0+P.μ2^2)^2\n    )\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"We should also have a routine for evaluating the ϕ function:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"function ϕ(x, P::DD.DiffusionProcess)\n    b = DD.b(nothing, x, P)\n    0.5*(dot(b,b) + sum(b_prime(x, P)))\nend\n\nb_prime(x, P::BivariateDoubleWell) = @SVector [\n    -P.μ2^2*P.ρ2,\n    2.0*P.ρ1*P.μ1 - 6.0*P.ρ1*x[2]^2 - P.ρ2,\n]","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"As well as for computing the acceptance probability for the simulated proposal path:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"function acc_prob(X, P::DD.DiffusionProcess, l=inf_ϕ(P))\n    logprob = 0.0\n    for i in 1:length(X)-1\n        dt = X.t[i+1]-X.t[i]\n        logprob -= (ϕ(X.x[i], P) - l)*dt\n    end\n    exp(logprob)\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Finally, we want to have a routine for sampling from the proposal law, which in our case is the law of Brownian bridges (see the relevant how-to-guide for more details).","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"using Random\nstruct BrownianBridge end\n\nfunction Random.rand!(::BrownianBridge, X, x0=zero(X.x[1]), xT=zero(X.x[1]))\n    rand!(Wiener(), X)\n    T, B_T = X.t[end], X.x[end]\n    λ(t, x) = ( x0 + x + (xT - x0 - B_T) * t/T )\n    X.x .= λ.(X.t, X.x)\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"We are now ready to implement rejection sampling on a path space.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"function Base.rand(P::DD.DiffusionProcess, tt, x0, xT, ::RejectionSampling)\n    X° = trajectory(tt, P).process\n    # compute constant l only once, it won't change anyway\n    l = inf_ϕ(P)\n    while true\n        # proposal draw\n        rand!(BrownianBridge(), X°, x0, xT)\n\n        # accept/reject; if reject then re-sample and retry; if accept then return X°\n        (rand() <= acc_prob(X°, P, l)) && return X°\n    end\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"That's it! As you can see for yourself: a beautifully simple algorithm. Let's test it. We will be using the following parameterization","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"θ = (\n    ρ1 = 0.5,\n    ρ2 = 0.5,\n    μ1 = 2.0,\n    μ2 = 1.0\n)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"The bivariate double-well potential is—as the name suggests it–a diffusion with a stationary distribution that has two modes. These modes are at:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"mode1 = @SVector [sqrt(θ.μ1)/θ.μ2, sqrt(θ.μ1)]\nmode2 = @SVector [-sqrt(θ.μ1)/θ.μ2,-sqrt(θ.μ1)]","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Consequently, when we simulate the trajectory over long intervals we should observe the trajectories being attracted to these two poles.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Let's start modestly and try to simulate 30 bridge trajectories over the interval 03 that join the two diffusion modes","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"P = BivariateDoubleWell(θ...)\ntt = 0.0:0.01:3.0\n\nN = 30\npaths = [rand(P, tt, mode1, mode2, RejectionSampling()) for i in 1:N]\n\nusing Plots\np = plot(size=(800, 500), layout=(2,1))\nfor i in 1:N\n    plot!(p, paths[i], Val(:vs_time), alpha=[0.2 0.2], color=[\"steelblue\" \"steelblue\"], label=[\"X₁\" \"X₂\"])\nend\ndisplay(p)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"(Image: rej_sampling_simple)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"When you run the code above you might be slightly surprised because of two reasons.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"First, where is the bimodality behavior we talked about?\nSecond, why did the code not execute immediately? Seemingly there aren't that many computations to be performed! On my computer it takes around 1.5second to simulate the trajectories. Why so long?","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"To answer the first concern, the bimodal behavior becomes pronounced only over long enough time-spans. The time span we used was simply too short and the trajectories ended-up being stretched around a straight line that connects the end-points. Had we taken longer time-spans the behavior would have been more pronounced. But let's not jump ahead of ourselves by trying to run the algorithm above with larger T. Indeed, the reason for the slow performance of the code above is that an already seemingly short time-span of 03 is troublesome for the sampler and most proposals end up being rejected. We can modify the routine a little to examine the magnitude of the problem","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"function Base.rand(P::DD.DiffusionProcess, tt, x0, xT, ::RejectionSampling)\n    X° = trajectory(tt, P).process\n    # compute constant l only once, it won't change anyway\n    l = inf_ϕ(P)\n    num_prop = 0\n    while true\n        # proposal draw\n        rand!(BrownianBridge(), X°, x0, xT)\n        num_prop += 1\n\n        # accept/reject; if reject then re-sample and retry; if accept then return X°\n        (rand() <= acc_prob(X°, P, l)) && (\n            println(\"Proposed $num_prop trajectories until acceptance\");\n            return X°;\n        )\n    end\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"And let's see what is the ballpark figure for the number of proposals until acceptance:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"[rand(P, tt, mode1, mode2, RejectionSampling()) for i in 1:5]\nProposed 4168 trajectories until acceptance\nProposed 762 trajectories until acceptance\nProposed 1939 trajectories until acceptance\nProposed 4816 trajectories until acceptance\nProposed 14576 trajectories until acceptance","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Thousands of proposals for a single accepted path! That's not very efficient...","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"You might be thinking to yourself how bad could it get if we try to increase T nevertheless? It turns out exponentially bad. For instance:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"julia> tt = 0.0:0.01:4.0\n0.0:0.01:4.0\n\njulia> paths = [rand(P, tt, mode1, mode2, RejectionSampling()) for i in 1:5]\nProposed 274113 trajectories until acceptance\nProposed 22926 trajectories until acceptance\nProposed 8498 trajectories until acceptance\nProposed 258171 trajectories until acceptance\nProposed 216711 trajectories until acceptance","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Hundreds of thousands of proposals for a single acceptance... If you are about to grab a cup of coffee you can also run the following:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"julia> tt = 0.0:0.01:5.0\n0.0:0.01:5.0\n\njulia> paths = [rand(P, tt, mode1, mode2, RejectionSampling()) for i in 1:5]\nProposed 82423 trajectories until acceptance\nProposed 4279263 trajectories until acceptance\nProposed 1524125 trajectories until acceptance\nProposed 5512559 trajectories until acceptance\nProposed 3745595 trajectories until acceptance","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Millions of proposals until acceptance... Trying larger Ts is probably not advisable here unless you are going away for a holiday.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"note: Note\nOn the plus side, the bimodality is slowly revealing itself:using Plots\nN = 5\np = plot(size=(800, 500), layout=(2,1), title=[\"X₁\" \"X₂\"])\nfor i in 1:N\n    plot!(p, paths[i], Val(:vs_time), alpha=[0.5+0.8*(i==N) 0.5+0.5*(i==N)], color=[\"steelblue\" \"steelblue\"], label=\"\")\nend\ndisplay(p)(Image: rej_sampling_simple_on5)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"This is all to say that rejection sampling is not suitable for sampling long diffusion bridges. On the other hand, we should appreciate what we have achieved. We have sampled independent and identically distributed trajectories from the law of a bivariate double-well potential diffusion bridge! And we did it by sampling exclusively from the law of Brownian bridges. This is nothing to be taken for granted and it is an impressive result in itself. Nevertheless, we can still do better, even within the scope of this tutorial.","category":"page"},{"location":"tutorials/diffusion_bridges/#Importance-Sampling-on-a-path-space-1","page":"Sampling of diffusion bridges","title":"Importance Sampling on a path space","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Importance sampling can be thought of as a modification to rejection sampling, where the accept/reject step is substituted with decorating each sample with a weight. To be more precise, the term that was used as an acceptance probability is now used as a weight and is returned together with a sample. The algorithm becomes:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"struct ImportanceSampling end\n\nfunction Base.rand(P::DD.DiffusionProcess, tt, x0, xT, ::ImportanceSampling)\n    X° = trajectory(tt, P).process\n    # constant l no longer needs to be computed as all weights contain it\n    l = 0.0 # was `inf_ϕ(P)`\n\n    rand!(BrownianBridge(), X°, x0, xT)\n\n    return X°, acc_prob(X°, P, l)\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"The first advantage of importance sampling is that we only need to know weights up to a constant of proportionality (in particular, we don't need to know M from \\eqref{eq:accpprobrs}, or l from \\eqref{eq:phi_function}). In particular for diffusions, we don't even need to know the potential function A. This relaxation of technical conditions makes it possible to apply importance sampling to diffusion laws that couldn't have been sampled with rejection sampling. It doesn't however help with the computational cost. True, the accept/reject step is no longer there, so it only takes one execution of the routine to yield an output, however, most of these samples are going to have very low weights attached to them, meaning that they won't be of much use (though they will still have some use, as opposed to the samples rejected by the rejection sampler). For instance:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"tt = 0.0:0.01:3.0\nweights = [rand(P, tt, mode1, mode2, ImportanceSampling())[2] for i in 1:Int(1e4)]\nhistogram(weights./sum(weights), norm=true, label=\"distribution of normalized weights\")","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"(Image: weight_distr) while","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"julia> round.(sort(weights)[end-9:end]./sum(weights), sigdigits=3)\n10-element Array{Float64,1}:\n 0.0021\n 0.00213\n 0.00214\n 0.00223\n 0.00224\n 0.00232\n 0.00236\n 0.00323\n 0.00372\n 0.00382","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Computation of expectations of path functionals might however be better behaved.","category":"page"},{"location":"tutorials/diffusion_bridges/#Independence-sampler-on-a-path-space-1","page":"Sampling of diffusion bridges","title":"Independence sampler on a path space","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"The next algorithm on our list of improvements is an independence sampler. By itself it doesn't strike as being particularly beneficial–at most it seems to afford a change of perspective–but it will become an important stepping stone to more efficient algorithms.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Independence sampler is a particular, simple type of Metropolis–Hastings algorithm. Samples are repeatedly generated independently (hence the name) according to some proposal density X^circsim dmathbbQ and each proposal draw is either accepted with probability","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"a(XX^circ)= 1frac\n    fracdmathbbPdmathbbQ(X^circ)\n\n    fracdmathbbPdmathbbQ(X)\n","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"or is otherwise rejected. In case of acceptance we set XX^circ, whereas otherwise, we simply reject X^circ and leave X unchanged. The output of the algorithm is a chain of accepted Xs, whose stationary distribution will be given by mathbbP.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"You can think of this Metropolis–Hastings algorithm as a stack of importance samplers that use computed weights","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"w(X)proptofracdmathbbPdmathbbQ(X)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"to evaluate the acceptance probability for the accept/reject step. In Julia we can write:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"struct IndependenceSampler end\n\nfunction Base.rand(P::DD.DiffusionProcess, tt, x0, xT, num_iter, ::IndependenceSampler)\n    X = trajectory(tt, P).process\n    X° = deepcopy(X)\n    rand!(BrownianBridge(), X, x0, xT)\n    w = acc_prob(X, P, 0.0) # weight\n\n    num_accpt = 0\n    for i in 1:num_iter\n        # sample proposal\n        rand!(BrownianBridge(), X°, x0, xT)\n        # compute its weight\n        w° = acc_prob(X°, P, 0.0)\n\n        # Metropolis–Hastings step\n        if rand() <= w°/w # note that l (no matter its value) cancels out\n            X, X° = X°, X\n            w = w°\n            num_accpt += 1\n        end\n    end\n    println(\"accpt rate: \", num_accpt/num_iter)\n\n    return X\nend\n\nrand(P, tt, mode1, mode2, 1e4, IndependenceSampler())","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"where we've added some message about acceptance rate. It's a useful metric for practice.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Independence sampler does not address the issue of the computational issues that we had before as the proposals are still sampled blindly from the Wiener law. However, it takes us right to the front door of some algorithms that do.","category":"page"},{"location":"tutorials/diffusion_bridges/#Metropolis–Hastings-algorithm-with-local-updates-1","page":"Sampling of diffusion bridges","title":"Metropolis–Hastings algorithm with local updates","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"The power of the Metropolis–Hastings algorithm comes from the fact that we don't need to make independent updates and we may instead use local updates that exploit the fact that an already accepted path must have been somewhat good for it to be accepted. In particular, for the diffusion laws we can use a technique called preconditioned Crank–Nicolson scheme to–instead of sample diffusion paths independently from the Brownian bridge laws–perturb the already accepted paths locally. The mathematical details are beyond the scope of this tutorial (though they are not complicated and you might be able to figure them out from looking at the code below), but the preconditioned Crank–Nicolson scheme (with an additional step of non-centered parameterization) can be implemented as follows:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"function noncenter_and_crank_nicolson!(X°, X, ρ)\n    # \"non-centered parameterization\"\n    rev_x° = zero_out_Brownian_birdge!(X°)\n    rev_x = zero_out_Brownian_birdge!(X)\n\n    # local move\n    crank_nicolson!(X°.x, X.x, ρ)\n\n    # transform back to regular parameterization\n    rev_x°(X°)\n    rev_x(X)\nend\n\n# transforms x0-xT Brownian bridges to 0-0 Brownian bridges\n# and returns a transformation that can do the reverse\nfunction zero_out_Brownian_birdge!(X)\n    T, x0, xT = X.t[end], X.x[1], X.x[end]\n    λ(t, x) = ( x - x0 - (xT - x0)*t/T )\n    X.x .= λ.(X.t, X.x)\n    λ_rev(t, x) = ( x0 + x + (xT - x0) * t/T )\n    reversal!(x) = (x.x .= λ_rev.(x.t, x.x))\n    reversal!\nend\n\n# perturbs the path y locally in the direction given by y°, saves to y°\nfunction crank_nicolson!(y°, y, ρ)\n    λ = sqrt(1-ρ^2)\n    y° .= λ .* y° .+ ρ .* y\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"With this scheme we can run a Metropolis–Hastings algorithm with local updates of trajectories","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"struct MetropolisHastings end\n\nfunction Base.rand(P::DD.DiffusionProcess, tt, x0, xT, num_iter, ::MetropolisHastings; ρ=0.0, save_every=100)\n    X = trajectory(tt, P).process\n    X° = deepcopy(X)\n    rand!(BrownianBridge(), X, x0, xT)\n    w = acc_prob(X, P, 0.0) # weight\n\n    paths = []\n    num_accpt = 0\n    for i in 1:num_iter\n        # sample proposal\n        rand!(BrownianBridge(), X°, x0, xT)\n        # but move it only a little by perturbing X\n        noncenter_and_crank_nicolson!(X°, X, ρ)\n        # compute its weight\n        w° = acc_prob(X°, P, 0.0)\n\n        # Metropolis–Hastings step\n        if rand() <= w°/w # note that l (no matter its value) cancels\n            X, X° = X°, X\n            w = w°\n            num_accpt += 1\n        end\n\n        # save an accepted path once in a while\n        (i % save_every == 0) && push!(paths, deepcopy(X))\n    end\n    println(\"acceptance rate: \", num_accpt/num_iter)\n\n    return paths\nend","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"Parameter ρin01) is called a memory parameter of the preconditioned Crank–Nicolson scheme. It indicates how much the sampling of new trajectories relies on the previously accepted path (ρ=0 indicating independence sampler and ρ=1 a degenerate sampler that does not move at all, because it is bound to the previously accepted path forever).","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"On one hand, when we set ρ to higher values, then sampling becomes easier (acceptance rate increases), on the other hand we don't move much and we need to make many more steps. You might worry that in a haste of improving computational cost due to length of bridges by increasing ρ we might be falling from the frying pan into the fire and trade one source of computational burden for the exact amount of another. This however is not the case, as the cost due to length of bridges is exponential, whereas that due to ρ scales much better.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"To see it for yourself, let's try to sample bridges over a much longer time span, say 020. It would probably take years to sample a single bridge of this length (for our example) using rejection sampling on a path space. But it is possible with the Metropolis–Hastings algorithm with local moves on a path space.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"P = BivariateDoubleWell(θ...)\n\ntt = 0.0:0.01:20.0\npaths = rand(P, tt, mode1, mode2, 1e5, MetropolisHastings(), ρ=0.997, save_every=1000)\n\np = plot(size=(800, 500), layout=(2,1), title=[\"X₁\" \"X₂\"])\nfor i in eachindex(paths)\n    a = (i == length(paths))\n    plot!(p, paths[i], Val(:vs_time), alpha=[0.1+a 0.1+a], color=[\"steelblue\" \"steelblue\"], label=\"\")\nend\ndisplay(p)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"(Image: metrop_hastings)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"As you can see the bimodality is now much more pronounced. We can even observe it more strongly if we consider a harder problem of different parameterization for which modes have a greater separation.","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"θ = (\n    ρ1 = 0.5,\n    ρ2 = 0.5,\n    μ1 = 4.0,\n    μ2 = 1.0\n)\nmode1 = @SVector [sqrt(θ.μ1)/θ.μ2, sqrt(θ.μ1)]\nmode2 = @SVector [-sqrt(θ.μ1)/θ.μ2,-sqrt(θ.μ1)]\n\nP = BivariateDoubleWell(θ...)\n\ntt = 0.0:0.01:20.0\npaths = rand(P, tt, mode1, mode2, 1e5, MetropolisHastings(), ρ=0.999, save_every=1000)\n\np = plot(size=(800, 500), layout=(2,1), title=[\"X₁\" \"X₂\"])\nfor i in eachindex(paths)\n    a = 0.9*(i == length(paths))\n    plot!(p, paths[i], Val(:vs_time), alpha=[0.1+a 0.1+a], color=[\"steelblue\" \"steelblue\"], label=\"\")\nend\ndisplay(p)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"(Image: metrop_hastings_dist_modes)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"However, before calling it a victory let's run the algorithm again and see what happens:","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"paths = rand(P, tt, mode1, mode2, 1e5, MetropolisHastings(), ρ=0.999, save_every=1000)\n\np = plot(size=(800, 500), layout=(2,1), title=[\"X₁\" \"X₂\"])\nfor i in eachindex(paths)\n    a = 0.9*(i == length(paths))\n    plot!(p, paths[i], Val(:vs_time), alpha=[0.1+a 0.1+a], color=[\"steelblue\" \"steelblue\"], label=\"\")\nend\ndisplay(p)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"(Image: metrop_hastings_dist_modes2)","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"The paths look quite different! It appears that 1e5 is not enough steps to fully explore the stationary distribution for this example and a much greater number of steps will be needed. Diagnosing whether your chain has converged or not is part science, part experience, (and sometimes) part art.","category":"page"},{"location":"tutorials/diffusion_bridges/#Concluding-remarks-1","page":"Sampling of diffusion bridges","title":"Concluding remarks","text":"","category":"section"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"TODO","category":"page"},{"location":"tutorials/diffusion_bridges/#","page":"Sampling of diffusion bridges","title":"Sampling of diffusion bridges","text":"tip: Exercise\nModify rejection sampling on a path space for a bivariate double well potential with a diagonal volatility coefficient with diagonal entries σ_1 and σ_2.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#Understanding-in-place-and-out-of-place-methods-and-how-to-call-them-1","page":"In-place vs out-of-place methods","title":"Understanding in-place and out-of-place methods and how to call them","text":"","category":"section"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"DiffusionDefinition.jl provides support for both in-place and out-of-place sampling. So which one should you use? In this tutorial we will illustrate which one of the two modes should be used on the example of a Lorenz96 system.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#Lorenz-'96-system-1","page":"In-place vs out-of-place methods","title":"Lorenz '96 system","text":"","category":"section"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"In this tutorial we will be using a Lorenz '96 system. More details about it can be found here. We will be using it because it is a model that can be defined for different dimension D of the state space. The model is pre-defined in the package and can be simply loaded in with @load_variable_diffusion, however, for didactic purposes we will define it explicitly using @diffusion_process.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#Out-of-place-methods-1","page":"In-place vs out-of-place methods","title":"Out-of-place methods","text":"","category":"section"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"Out-of-place methods are the type of methods that are allowed to allocate new space for performing computations. If you are able to ascertain that your variables live on a stack allocated memory, then out-of-place operations can be very efficient. For DiffusionDefinition.jl this corresponds to the state of the diffusion process being represented either by Numbers or SArrays. So the question becomes: if the state-space of your diffusion is RR^d, when does it make sense to have it represented by SArrays? Should we simply always use SArrays? To answer this question you should simply consult the documentation of StaticArrays. It states clearly that if your objects become greater in dimension than 100, then the benefits of using SArrays start to taper off and it is better to use regular arrays.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"For diffusion processes the largest element will most often be a volatility matrix. If it is represented by a dense array, then for diffusions living on RR^10 and higher we should start re-considering use of out-of-place methods. If the volatility matrix can be kept sparse (or in particular diagonal) then the limit for using out-of-place methods are rather diffusions living in RR^100. As a general rule of thumb you should use SArrays (or Numbers) for dimension less than that and regular Arrays otherwise.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#Example-1","page":"In-place vs out-of-place methods","title":"Example","text":"","category":"section"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"Let's define a 50 dimensional Lorenz '96 system:","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"@diffusion_process Lorenz96_OOP begin\n    :dimensions\n    process --> 50\n    wiener --> 50\n\n    :parameters\n    (θ, σ) --> Float64\n\n    :additional\n    constdiff --> true\nend\n\nconst si1 = SVector{50,Int64}(mod1.(2:51, 50))\nconst si2 = SVector{50,Int64}(mod1.(-1:48, 50))\nconst si3 = SVector{50,Int64}(mod1.(0:49, 50))\nconst si4 = SVector{50,Int64}(1:50)\n\n@inline function b(t, x, P::Lorenz96_OOP)\n    ( view(x, si1) .- view(x, si2) ) .* view(x, si3) .- view(x, si4) .+ P.θ\nend\n\nσ(t, x, P::Lorenz96_OOP) = P.σ * SDiagonal{50,Float64}(I)","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"Note that any subindexing must be done with SVectors to avoid creating regular arrays first that are later converted to SArrays.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#In-place-methods-1","page":"In-place vs out-of-place methods","title":"In-place methods","text":"","category":"section"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"In-place methods are those assumed to have a pre-allocated, fixed amount of memory on which all operations are to be performed. Based on the previous section, you can imagine that in-place methods should simply be used whenever out-of-place methods cannot.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#Example-2","page":"In-place vs out-of-place methods","title":"Example","text":"","category":"section"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"For instance if we bump the dimension of the Lorenz '96 system to, say 10000, then we should most certainly switch to regular arrays. This time however, the output of the drift and volatility should be saved into a pre-allocated buffer.","category":"page"},{"location":"tutorials/in_place_vs_out_of_place/#","page":"In-place vs out-of-place methods","title":"In-place vs out-of-place methods","text":"@diffusion_process Lorenz96_IP begin\n    :dimensions\n    process --> 10000\n    wiener --> 10000\n\n    :parameters\n    (θ, σ) --> Float64\n\n    :additional\n    constdiff --> true\nend\n\nconst i1 = mod1.(2:10001, 10000)\nconst i2 = mod1.(-1:9998, 10000)\nconst i3 = mod1.(0:9999, 10000)\nconst i4 = 1:10000\n\nfunction b!(buffer, t, x, P::Lorenz96_IP)\n    buffer.b .= ( view(x, i1) .- view(x, i2) ) .* view(x, i3) .- view(x, i4) .+ P.θ\nend\n\nσ!(buffer, t, x, P::Lorenz96_IP) = (buffer.σ.diag .= P.σ)","category":"page"},{"location":"predefined_processes/sir/#Susceptible-Infectious-Recovered-model-1","page":"SIR model","title":"Susceptible-Infectious-Recovered model","text":"","category":"section"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"A simple, scalar-valued susceptible-infectious-recovered (SIR) model defined by a two-dimension diffusion process solving the following SDE","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"beginalign*\ndd I_t = (alpha (1-I_t-R_t)I_t - beta I_t)dd t -sigma_1sqrt(1-I_t-R_t)I_t dd W^(1)_t - sigma_2sqrtI_tdd W^(2)_t\ndd R_t = beta I_t dd t + sigma_2sqrtI_t dd W^(2)_t\nendalign*","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"with I_tin01 and R_tin01 for all tin0T. It can be called with:","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"@load_diffusion SIR","category":"page"},{"location":"predefined_processes/sir/#Example-1","page":"SIR model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion SIR\nθ = [0.37, 0.05, 0.03, 0.03]\nP = SIR(θ...)\ntt, y1 = 0.0:0.001:100.0, @SVector [0.001, 0.001]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), label=[\"infected\" \"recovered\"])\nplot!(X.t, map(x->1.0-x[1]-x[2], X.x), label=\"susceptible\")","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"(Image: sir)","category":"page"},{"location":"predefined_processes/sir/#Auxiliary-diffusion-1","page":"SIR model","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"We additionally define a suitable linear process that can be used in the setting of guided proposals. It is a solution to the following SDE","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"beginalign*\ndd widetildeI_t = (alpha (1-widetildeI_t-widetildeR_t)widetildeI_t - beta widetildeI_t)dd t -sigma_1(1-widetildeI_t-widetildeR_t)widetildeI_t dd W^(1)_t - sigma_2widetildeI_tdd W^(2)_t\ndd widetildeR_t = beta widetildeI_t + sigma_2widetildeI_t dd W^(2)_t\nendalign*","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"and can be called with","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"@load_diffusion SIRAux","category":"page"},{"location":"predefined_processes/sir/#Example-2","page":"SIR model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion SIRAux\nθ = [0.37, 0.05, 0.03, 0.03]\nt, T, vT = 0.0, 5.0, @SVector [0.5, 0.1]\nP = SIRAux(θ..., t, T, vT)\ntt, y1 = t:0.001:T, @SVector [0.04, 0.02]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), label=[\"infected\" \"recovered\"])\nplot!(X.t, map(x->1.0-x[1]-x[2], X.x), label=\"susceptible\")","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"(Image: sir_aux)","category":"page"},{"location":"predefined_processes/jansen_rit/#Jansen-Rit-model-1","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"","category":"section"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"Neural Mass Model used to describe the EEG data. It is a six-dimensional diffusion process driven by a three-dimensional Wiener process that is a solution to the following stochastic differential equation","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"beginequation*\n    beginaligned\n        dd X_t = dot X_t dd t  \n        dd Y_t = dot Y_t dd t  \n        dd Z_t = dot Z_t dd t \n        dd dot X_t =   leftA a left(mu_x(t) + mboxSigm(Y_t - Z_t)right) - 2a dot X_t - a^2 X_tright d t + sigma_x dd W^(1)_t\n        dd dot Y_t =  leftA a left(mu_y(t) + C_2mboxSigm(C_1 X_t)right) - 2a dot Y_t - a^2 Y_tright d t + sigma_y dd W^(2)_t\n        dd dot Z_t =  leftB b left(mu_z(t) + C_4mboxSigm(C_3 X_t)right) - 2b dot Z_t - b^2 Z_tright dd t + sigma_z dd W^(3)_t\n    endaligned\nendequation*","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"with initial condition","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"(X_0Y_0Z_0 dot X_0 dot Y_0 dot Z_0)=(x_0y_0z_0 dot x_0 dot y_0 dot z_0) in RR^6","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"where","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"mboxSigm(x) = fracnu_max1 + e^r(v_0 - x)","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"and","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"mu_x(t) =mu_xqquad mu_y(t) =mu_y mu_z(t) =mu_z","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"and","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"C_1 = C quad C_2 = 08C quad C_4 = C_3 = 025C","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"Can be imported with","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"@load_diffusion JansenRit","category":"page"},{"location":"predefined_processes/jansen_rit/#Example-1","page":"Jansen-Rit model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion JansenRit\nθ = [3.25, 100.0, 22.0, 50.0 , 135.0, 5.0, 6.0, 0.56, 0.0, 220.0, 0.0, 0.01, 2000.0, 1.0]\nP = JansenRit(θ...)\ntt, y1 = 0.0:0.0001:3.0, @SVector [0.11, 24, 17, -0.5, 0.0, 0.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), layout=(3,2), size=(1000,800))","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"(Image: jansen_and_rit)","category":"page"},{"location":"manual/drift_and_volatility/#Defining-the-drift-and-the-volatility-coefficient-1","page":"Drift and volatility","title":"Defining the drift and the volatility coefficient","text":"","category":"section"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"To complete the definition of a diffusion process we need to specify its drift, as well as its volatility coefficient. For the Lorenz example from the previous section we can do this by writing:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"const DD = DiffusionDefinition\nusing StaticArrays\n\nfunction DD.b(t, x, P::Lorenz)\n    @SVector [\n        P.p1*(x[2]-x[1]),\n        P.p2*x[1] - x[2] - x[1]*x[3],\n        x[1]*x[2] - P.p3*x[3]\n    ]\nend\n\nDD.σ(t, x, P::Lorenz) = SDiagonal(P.σ, P.σ, P.σ)","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"The two functions above are out-of-place i.e. they return new vectors (that live on a stack, because of StaticArrays). We may alternatively define the drift and diffusion coefficients to be in-place as follows:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"function DD.b!(buffer, t, x, P::Lorenz)\n    buffer.b[1] = P.p1*(x[2]-x[1])\n    buffer.b[2] = P.p2*x[1] - x[2] - x[1]*x[3]\n    buffer.b[3] = x[1]*x[2] - P.p3*x[3]\nend\n\nDD.σ!(buffer, t, x, P::Lorenz) = (buffer.σ.diag .= P.σ)","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"In this case case the output is saved to a buffer, which must have appropriate fields b and σ with enough pre-allocated space (see also the section on buffers).","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"note: Note\nall of the functions DD.b, DD.b!, DD.σ and DD.σ! are defined to overload the functionality inside the DiffusionDefinition module (accessing it via DD) and NOT the Main module.\nthe arguments for the out-of-place method are (t, x, P::DIFFUSION_NAME), whereas those for in-place are (buffer, t, x, P::DIFFUSION_NAME).","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"tip: Tip\nAlways use StaticArrays for out-of-place drift and volatility! If functions using DD.b and DD.σ are faster with regular arrays, then you shouldn't be using out-of-place methods in the first place, but DD.b! and DD.σ! instead. A general rule of thumb is to use DD.b and DD.σ for low dimensional diffusions (up to dimension ~10 for elliptic diffusions with dense volatility coefficients or up to dimension ~100 for those with sparse volatility coefficients) and use in-place methods otherwise.","category":"page"},{"location":"manual/drift_and_volatility/#default_types_for_P-1","page":"Drift and volatility","title":"Telling Julia whether to use (DD.b, DD.σ) or (DD.b!, DD.σ!)","text":"","category":"section"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"Some functions implemented in this package have two versions: one relying on out-of-place methods, another on in-place methods. For instance:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"DiffusionDefinition.solve!(XX, WW, P, y1)","category":"page"},{"location":"manual/drift_and_volatility/#DiffusionDefinition.solve!-NTuple{4,Any}","page":"Drift and volatility","title":"DiffusionDefinition.solve!","text":"solve!(XX, WW, P, y1)\n\nCompute a trajectory, started from y1 and following the diffusion law P, from the sampled Wiener process WW. Save the sampled path in XX. Return prematurely with a false massage if the numerical scheme has led to the solver violating the state-space restrictions.\n\n\n\n\n\n","category":"method"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"and","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"DiffusionDefinition.solve!(XX, WW, P, y1, buffer)","category":"page"},{"location":"manual/drift_and_volatility/#DiffusionDefinition.solve!-NTuple{5,Any}","page":"Drift and volatility","title":"DiffusionDefinition.solve!","text":"solve!(XX, WW, P, y1, buffer)\n\nSame as solve!(XX, WW, P, y1), but additionally provides a pre-allocated buffer for performing in-place computations.\n\n\n\n\n\n","category":"method"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"Calling one or the other will tell Julia which pair of functions (DD.b, DD.σ) or (DD.b!, DD.σ!) to use. However, most functions do not explicitly come in two versions, and instead, they rely on some hint from the user to decide on the mode of computation. There are two ways in which Julia can be given such hints:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"If the function accepts optional inputs (such as a starting point) or expects to receive containers that the results are saved into (such as containers for diffusion paths), then the DataType of said inputs will be used to decide on the mode of computation (if DataType used for state space is immutable, then out-of-place methods are used, otherwise in-place methods are used). These hints will overwrite the second method below.\nSometimes no such inputs can be passed or there is an option of relying on defaults. In that case Julia will use default information specified by functions:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"DiffusionDefinition.default_type\nDiffusionDefinition.default_wiener_type","category":"page"},{"location":"manual/drift_and_volatility/#DiffusionDefinition.default_type","page":"Drift and volatility","title":"DiffusionDefinition.default_type","text":"default_type(::DiffusionProcess{T,DP})\n\nAllows for inference of data type that encodes the state space of a given diffusion.\n\n\n\n\n\n","category":"function"},{"location":"manual/drift_and_volatility/#DiffusionDefinition.default_wiener_type","page":"Drift and volatility","title":"DiffusionDefinition.default_wiener_type","text":"default_wiener_type(::DiffusionProcess{T,DP,DW})\n\nAllows for inference of data type that encodes the state space of the Brownian motion driving a given diffusion process.\n\n\n\n\n\n","category":"function"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"By default, these two are set to StaticArrays resulting in out-of-place computations by default. To change that, overwrite the two functions for your diffusion type. For instance, for the Lorenz example, to change the default mode of computation to out-of-place write:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"default_type(::Lorenz) = Vector{Float64}\ndefault_wiener_type(::Lorenz) = Vector{Float64}","category":"page"},{"location":"predefined_processes/lorenz63/#Lorenz-'63-system-1","page":"Lorenz63 system","title":"Lorenz '63 system","text":"","category":"section"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"Famous Lorenz attractor, a three-dimensional elliptic diffusion, a solution to the following stochastic differential equation","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"beginalign*\ndd X_t = theta_1 (Y_t - X_t) dd t + sigma dd W^(1)_t \ndd Y_t = X_t (theta_2 - Z_t) - Y_tdd t + sigma dd W^(2)_t\ndd Z_t = X_t Y_t - theta_3 Z_tdd t + sigma dd W^(3)_t\nendalign*","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"Can be imported with the following command","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"@load_diffusion :Lorenz","category":"page"},{"location":"predefined_processes/lorenz63/#Example-1","page":"Lorenz63 system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion Lorenz\nθ = [10.0, 28.0, 8.0/3.0, 1.0]\nP = Lorenz(θ...)\ntt, y1 = 0.0:0.001:10.0, @SVector [-10.0, -10.0, 25.0]\nX = rand(P, tt, y1)\nplot(X, Val(:x_vs_y), coords=[1,3])","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"(Image: lorenz)","category":"page"},{"location":"predefined_processes/lorenz63/#Auxiliary-diffusion-1","page":"Lorenz63 system","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"We additionally provide an implementation of a linear diffusion that can be used in a setting of guided proposals. It is defined as a solution to the following SDE:","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"beginalign\ndd wtX_t = left-theta_1 wtX_t + theta_2wtY_trightdd t + sigma dd W^(1)_t\ndd wtY_t = left (theta_2-z_T)wtX_t - wtY_t - x_TwtZ_t + x_Tz_T rightdd t + sigma dd W^(2)_t\ndd wtZ_t = left y_TwtX_t x_TwtX_t -theta_3wtZ_t -x_Ty_T rightdd t + sigma dd W^(3)_t\nendalign","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"It can be called with","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"@load_diffusion :LorenzAux","category":"page"},{"location":"predefined_processes/lorenz63/#Example-2","page":"Lorenz63 system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"@load_diffusion LorenzAux\nusing DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion LorenzAux\nθ = [10.0, 28.0, 8.0/3.0, 1.0]\nt, T, vT = 0.0, 10.0, @SVector [-10.0, -10.0, 25.0]\nP = LorenzAux(θ..., t, T, vT)\ntt, y1 = t:0.001:T, vT\nX = rand(P, tt, y1)\nplot(X, Val(:x_vs_y), coords=[1,3])","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"(Image: lorenz_aux)","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"note: Note\nNotice the limits of the axes! The auxiliary diffusion becomes an atrocious approximation to the Lorenz system over long time periods!","category":"page"},{"location":"predefined_processes/sine/#Sine-diffusion-1","page":"Sine diffusion","title":"Sine diffusion","text":"","category":"section"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"A simple, scalar diffusion process displaying multimodality on a path space. It solves the following stochastic differential equation","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"dd X_t = (a + bsin(c X_t))dd t + sigma dd W_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"It can be called with","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"@load_diffusion :Sine","category":"page"},{"location":"predefined_processes/sine/#Example-1","page":"Sine diffusion","title":"Example","text":"","category":"section"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"using DiffusionDefinition\nusing Plots\n\n@load_diffusion Sine\nθ = [1.0, 2.0, 8.0, 0.5]\nP = Sine(θ...)\ntt, y1 = 0.0:0.001:20.0, 0.0\nX = rand(P, tt, y1)\nplot(X)","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"(Image: sine)","category":"page"},{"location":"predefined_processes/sine/#Auxiliary-diffusion-1","page":"Sine diffusion","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"We define an additional, linear diffusion that can be used in the setting of guided proposals. It solves the following SDE","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"dd widetildeX_t = left(fracx_T-x_0T + fract5TwidetildeX_tright)dd t + sigma dd W_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"and can be called with","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"@load_diffusion :SineAux","category":"page"},{"location":"predefined_processes/sine/#Example-2","page":"Sine diffusion","title":"Example","text":"","category":"section"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"using DiffusionDefinition\nusing Plots\n\n@load_diffusion SineAux\nθ = [1.0, 2.0, 8.0, 0.5]\nt, T, y1, vT = 0.0, 20.0, 0.0, 4.0\nP = SineAux(θ..., t, T, y1, vT)\ntt = t:0.001:T\nX = rand(P, tt, y1)\nplot(X)","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"(Image: sine_aux)","category":"page"},{"location":"manual/state_space/#state_space_restrictions-1","page":"State space restrictions","title":"Restricting diffusion's state space","text":"","category":"section"},{"location":"manual/state_space/#","page":"State space restrictions","title":"State space restrictions","text":"","category":"page"},{"location":"manual/state_space/#","page":"State space restrictions","title":"State space restrictions","text":"Many standard diffusions are defined only on a subset of RR^d, and thus, it is often needed to restrict the state space on which trajectories can be sampled. We provide a set of structs that may be passed at the time of defining a diffusion law (calling the macro @diffusion_process) to restrict the state space of the diffusion","category":"page"},{"location":"manual/state_space/#","page":"State space restrictions","title":"State space restrictions","text":"DiffusionDefinition.UnboundedStateSpace\nDiffusionDefinition.LowerBoundedStateSpace\nDiffusionDefinition.UpperBoundedStateSpace\nDiffusionDefinition.BoundedStateSpace","category":"page"},{"location":"manual/state_space/#DiffusionDefinition.UnboundedStateSpace","page":"State space restrictions","title":"DiffusionDefinition.UnboundedStateSpace","text":"UnboundedStateSpace <: DiffusionStateSpace\n\nNo restrictions imposed on the state-space of the process (i.e. ℝᵈ)\n\n\n\n\n\n","category":"type"},{"location":"manual/state_space/#DiffusionDefinition.LowerBoundedStateSpace","page":"State space restrictions","title":"DiffusionDefinition.LowerBoundedStateSpace","text":"LowerBoundedStateSpace{T,S,N} <: DiffusionStateSpace\n\nLower bounds imposed on the state-space of a diffusion process. T is used to list the indices that have lower-bound restrictions, S indicates the values of the lower-bounds, N is the total number of coordinates with lower-bound restrictions\n\n\n\n\n\n","category":"type"},{"location":"manual/state_space/#DiffusionDefinition.UpperBoundedStateSpace","page":"State space restrictions","title":"DiffusionDefinition.UpperBoundedStateSpace","text":"UpperBoundedStateSpace{T,S,N} <: DiffusionStateSpace\n\nUpper bounds imposed on the state-space of a diffusion process. T is used to list the indices that have upper-bound restrictions, S indicates the values of the upper-bounds, N is the total number of coordinates with upper-bound restrictions\n\n\n\n\n\n","category":"type"},{"location":"manual/state_space/#DiffusionDefinition.BoundedStateSpace","page":"State space restrictions","title":"DiffusionDefinition.BoundedStateSpace","text":"BoundedStateSpace{L,U} <: DiffusionStateSpace\n\nUpper and lower bounds imposed on the state-space of a diffusion process. L corresponds to lower bounds, U corresponds to upper bounds.\n\n\n\n\n\n","category":"type"},{"location":"how_to_guides/sample_brownian_bridges/#how_to_guides-1","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"","category":"section"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"Brownian bridge is a Brownian motion conditioned to hit a pre-specified end-point.","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#Approximate-bridges-1","page":"How to sample Brownian bridges?","title":"Approximate bridges","text":"","category":"section"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"One way to sample Brownian bridges relies on an unconditioned SDE that describes the dynamics of a Brownian bridge (conditioned to hit x_TinRR^d).","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"dd X_t = fracx_T-X_tT-tdd t + dd W_tqquad X_0=x_0qquad tin0T","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"Define a diffusion with such a drift and then sample from it:","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"using DiffusionDefinition, Plots\nconst DD = DiffusionDefinition\n\n@diffusion_process BBApprox begin\n    :auxiliary_info\n    T --> Float64\n    xT --> Float64\nend\n\nDD.b(t, x, P::BBApprox) = (P.xT - x)/(P.T-t)\nDD.σ(t, x, P::BBApprox) = 1.0\n\nDD.default_type(::BBApprox) = Float64\nDD.default_wiener_type(::BBApprox) = Float64\n\nxT, T = -0.5, 2.0\nP = BBApprox(T, xT)\ntt, x0 = 0.0:0.001:T, 0.5\nX = rand(P, tt, x0)\n\nplot_kwargs = (color=\"steelblue\", label=\"\")\np = plot(X; plot_kwargs...)\nfor i in 1:30\n    plot!(p, rand(P, tt, x0); alpha=0.2, plot_kwargs...)\nend\ndisplay(p)","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"(Image: bb_approx)","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"note: Note\nBridges above rely on the Euler–Maruyama scheme and are thus burdened with an approximation error. To sample Brownian bridges devoid of any errors (without sacrificing any performance) use the method below.","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#Exact-bridges-1","page":"How to sample Brownian bridges?","title":"Exact bridges","text":"","category":"section"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"A preferred way of sampling Brownian bridges relies on a second identity that connects distributions of","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"W—a Brownian motion on 0T started from 0, and\nB—a Brownian bridge on 0T connecting x_0 and x_T:","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"left\n    x_0 + W_t + fractTleft( x_T-x_0-W_T right) tin0T\nright oversetd= B","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"B = trajectory(tt, Float64)\nW = rand(Wiener(), tt, 0.0)\nB.x .= x0 .+ W.x .+ tt./T.*(xT .- x0 .- W.x[end])\n\np = plot(B; plot_kwargs...)\nfor i in 1:30\n    W = rand(Wiener(), tt, 0.0)\n    B.x .= x0 .+ W.x .+ tt./T.*(xT .- x0 .- W.x[end])\n    plot!(p, B; alpha=0.2, plot_kwargs...)\nend\ndisplay(p)","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"(Image: bb_exact)","category":"page"},{"location":"how_to_guides/sample_brownian_bridges/#","page":"How to sample Brownian bridges?","title":"How to sample Brownian bridges?","text":"tip: Tip\nBoth method apply to sampling of multidimensional Brownian bridges as well!","category":"page"},{"location":"how_to_guides/sample_complex_valued/#How-to-sample-complex-valued-diffusions?-1","page":"How to sample complex-valued diffusions?","title":"How to sample complex-valued diffusions?","text":"","category":"section"},{"location":"how_to_guides/sample_complex_valued/#","page":"How to sample complex-valued diffusions?","title":"How to sample complex-valued diffusions?","text":"","category":"page"},{"location":"how_to_guides/sample_complex_valued/#","page":"How to sample complex-valued diffusions?","title":"How to sample complex-valued diffusions?","text":"From the perspective of internal mechanics of the package there is nothing special about complex valued processes. You simply need to make sure that you define the process with appropriate datatype, say ComplexF64.","category":"page"},{"location":"how_to_guides/sample_complex_valued/#Example-1","page":"How to sample complex-valued diffusions?","title":"Example","text":"","category":"section"},{"location":"how_to_guides/sample_complex_valued/#","page":"How to sample complex-valued diffusions?","title":"How to sample complex-valued diffusions?","text":"","category":"page"},{"location":"how_to_guides/sample_complex_valued/#","page":"How to sample complex-valued diffusions?","title":"How to sample complex-valued diffusions?","text":"The logo of this package was sampled using a complex-valued diffusion that has a mean reversion term that attracts the process towards a point that zooms around a unit circle on a complex plane:","category":"page"},{"location":"how_to_guides/sample_complex_valued/#","page":"How to sample complex-valued diffusions?","title":"How to sample complex-valued diffusions?","text":"using DiffusionDefinition\nconst DD = DiffusionDefinition\nusing Random, Plots\n\n@diffusion_process CustomComplexOU begin\n    :parameters\n    (θ, μ, σ) --> ComplexF64\nend\n\nDD.b(t, x, P::CustomComplexOU) = P.θ*(P.μ*exp(im*t) - x)\nDD.σ(t, x, P::CustomComplexOU) = P.σ\n\nDD.default_type(::CustomComplexOU) = ComplexF64\nDD.default_wiener_type(::CustomComplexOU) = ComplexF64\n\nRandom.seed!(10)\nθ = ComplexF64.([10.0, 0.15, 0.2])\nP = CustomComplexOU(θ...)\ntt, x0 = 0.0:0.0001:2π, ComplexF64(θ[2])\nX = rand(P, tt, x0)\nplot(map(x->real(x), X.x), map(x->imag(x), X.x), size=(500, 500))","category":"page"},{"location":"how_to_guides/sample_complex_valued/#","page":"How to sample complex-valued diffusions?","title":"How to sample complex-valued diffusions?","text":"(Image: impoverished_logo)","category":"page"},{"location":"post_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"post_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"post_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionDefinition]","category":"page"},{"location":"post_index/#DiffusionDefinition.Wiener","page":"Index","title":"DiffusionDefinition.Wiener","text":"struct Wiener{D,Tdevice}\nend\n\nA struct defining the Wiener process. D indicates the dimension of the process if it cannot be inferred from the DataType of the Trajectory. If the dimension can be inferred then it takes precedence over the value of D.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#Trajectories.trajectory-Tuple{Any,Type,Number}","page":"Index","title":"Trajectories.trajectory","text":"Trajectories.trajectory(tt, v::Type, D::Number)\n\nCreate a Trajectory with mutable states of dimension D along the time collection tt.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Trajectories.trajectory-Tuple{Any,Type}","page":"Index","title":"Trajectories.trajectory","text":"Trajectories.trajectory(tt, v::Type)\n\nCreate a Trajectory with immutable states along the time collection tt.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.@conjugate_gaussian-Tuple{Any,Expr}","page":"Index","title":"DiffusionDefinition.@conjugate_gaussian","text":"@conjugate_gaussian DIFFUSION_NAME begin\n    BODY\nend\n\nDefine helper functions for the conjugate gaussian updates of diffusion DIFFUSION_NAME. In BODY information can be passed as a list with elements of the form:\n\n:entry-name --> entry-value\n\nThe following entry names have special meaning: :inplace, :nonhypo, :hypo_a_inv. Any other name is interpreted as a parameter name for which function phi is defined. More precisely, the following can be defined:\n\n:inplace\n\n:inplace --> true\n\nto indicate that compmutations are to be done in-place. Otherwise, by default they are assumed to be done out-of-place.\n\n:nonhypo\n\n:nonhypo --> list-of-indices-with-non-degenerate-noise\n\ne.g.\n\n:nonhypo --> [1,3,5]\n\nto indicate which coordinates have non-degenerate (i.e. non-zero) Wiener term Wiener term. It automatically defines num_non_hypo for the user.\n\nwarning: Warning\nIf no flag :inplace --> true is passed, then it will be assumed that computations are done out-of-place by default and then no matter what subset you passed it will be internally saved as an SVector so as to work as a static way of accessing a subset of parameters. Otherwise, no change will be made to list-of-indices-with-non-degenerate-noise.\n\nhypo_a_inv\n\n:hypo_a_inv --> f(t,x,P)\n\nwhere f is a function that uses time variable t, state variable x and a struct with the target diffusion law P.\n\nphi and ignore_for_cu\n\n:name-of-parameter --> (φ₁(t,x,P), φ₂(t,x,P), ...)\n\nwhere φ₁(t,x,P) corresponds to all terms from the drift that are in the first non-degenerate coordinate and that are multiplied by the parameter with the name name-of-parameter, etc. Any parameters of P for which φ is not defined will have a function ignore_for_cu defined for them automatically and returning true.\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.@diffusion_process-Tuple{Any,Expr,Vararg{Any,N} where N}","page":"Index","title":"DiffusionDefinition.@diffusion_process","text":"diffusion_process(name, ex::Expr, p...)\n\nDefines a diffusion process according to a template described in the documentation of the github repository: https://github.com/mmider/DiffusionDefinition.jl\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.@load_diffusion-Tuple{Any}","page":"Index","title":"DiffusionDefinition.@load_diffusion","text":"@load_diffusion name\n\nLoads the predefined diffusion process.\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.@load_diffusion-Tuple{}","page":"Index","title":"DiffusionDefinition.@load_diffusion","text":"@load_diffusion\n\nDisplays available choices of predefined diffusion processes that can be loaded\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.AbstractSDESolver","page":"Index","title":"DiffusionDefinition.AbstractSDESolver","text":"abstract type AbstractSDESolver end\n\nSupertype of flags indicating ODE solvers\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.DiffusionProcess","page":"Index","title":"DiffusionDefinition.DiffusionProcess","text":"DiffusionProcess{T,DP,DW,SS,EI}\n\nTypes inheriting from DiffusionProcess define Ito diffusions. T denotes the datatype of each coordinate, DP the dimension of the stochastic process, DW the dimension of the Wiener process, SS lists the state space restrictions\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.DiffusionStateSpace","page":"Index","title":"DiffusionDefinition.DiffusionStateSpace","text":"DiffusionDomain\n\nTypes inheriting from DiffusionStateSpace define the types of restrictions put on the state-space of the stochastic process.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.EulerMaruyama","page":"Index","title":"DiffusionDefinition.EulerMaruyama","text":"struct EulerMaruyama <: AbstractSDESolver end\n\nFlag for indicating use of the Euler-Maruyama scheme for sampling diffusions. IMPORTANT: this is the only diffusion path sampler implemented in this package. There are no plans for implementing any other SDE solver in the forseeable future.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.LinearDiffusion","page":"Index","title":"DiffusionDefinition.LinearDiffusion","text":"LinearDiffusion{T,DP,DW,SS} <: DiffusionProcess{T,DP,DW,SS}\n\nTypes inheriting from LinearDiffusion define a linear Ito-type diffusion, i.e. solutions to stochastic differential equations of the form: dXₜ = (BₜXₜ + βₜ)dt + σₜdWₜ, t∈[0,T], X₀=x₀.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#Base.Unicode.lowercase-Tuple{Symbol}","page":"Index","title":"Base.Unicode.lowercase","text":"Base.lowercase(s::Symbol)\n\nLowercase all letters in a symbol\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Base.rand","page":"Index","title":"Base.rand","text":"Base.rand(w::Wiener, tt, y1)\n\nSamples Wiener process on tt, started from y1 and returns a new object with a sampled trajectory.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.B","page":"Index","title":"DiffusionDefinition.B","text":"B\n\nCompute matrix B of a linear diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.B!","page":"Index","title":"DiffusionDefinition.B!","text":"B!\n\nCompute matrix B of a linear diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition._bound_satisfied-Tuple{UnboundedStateSpace,Any}","page":"Index","title":"DiffusionDefinition._bound_satisfied","text":"bound_satisfied(::UnboundedStateSpace, x)\n\nNo restrictions, bounds satisfied by default\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._bound_satisfied-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{LowerBoundedStateSpace{T,S,N},Any}} where N where S where T","page":"Index","title":"DiffusionDefinition._bound_satisfied","text":"bound_satisfied(::LowerBoundedStateSpace{T,S,N}, x) where {T,S,N}\n\nChecks if all coordinates adhere to lower bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._bound_satisfied-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{UpperBoundedStateSpace{T,S,N},Any}} where N where S where T","page":"Index","title":"DiffusionDefinition._bound_satisfied","text":"bound_satisfied(::UpperBoundedStateSpace{T,S,N}, x) where {T,S,N}\n\nChecks if all coordinates adhere to upper bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._bound_satisfied-Union{Tuple{U}, Tuple{L}, Tuple{BoundedStateSpace{L,U},Any}} where U where L","page":"Index","title":"DiffusionDefinition._bound_satisfied","text":"bound_satisfied(::BoundedStateSpace{L,U}, x) where {L,U}\n\nChecks if all coordinates adhere to lower and upper bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._is_datatype-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition._is_datatype","text":"_is_datatype(sym, p)\n\nUtility function that checks whether sym is a datatype. It returns true if sym is either an in-built datatype (say float, StaticArray etc.) or if it is a template argument.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(::Any, ::Any)\n\nReturn false by default i.e. if the first argument is not a symbol nor its quote\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{QuoteNode,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(s::QuoteNode, symbols)\n\nCheck if quote of a symbol s is listed in a list of symbols symbols\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{Symbol,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(s::Symbol, symbols)\n\nCheck if symbol s is listed in a list of symbols symbols\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.a","page":"Index","title":"DiffusionDefinition.a","text":"a\n\nCompute the diffusion function σσ' of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.a!","page":"Index","title":"DiffusionDefinition.a!","text":"a!\n\nCompute the diffusion function σσ' of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.add_diff_function!-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.add_diff_function!","text":"add_diff_function!(fns, p)\n\nAdd a definition of a function consdiff that indicates if the diffusion coefficient is constant\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.b","page":"Index","title":"DiffusionDefinition.b","text":"b\n\nCompute the drift of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.b!","page":"Index","title":"DiffusionDefinition.b!","text":"b!\n\nCompute the drift of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.clone-Union{Tuple{T}, Tuple{T,AbstractDict}} where T<:DiffusionDefinition.DiffusionProcess","page":"Index","title":"DiffusionDefinition.clone","text":"clone(P::T, θ::AbstractDict) where T <: DiffusionProcess\n\nSimplified cloning of diffusion law P. Substitute relevant parameters with new values. θ must be a dict corresponding to parameters returned after a call to var_parameters.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.constdiff","page":"Index","title":"DiffusionDefinition.constdiff","text":"constdiff\n\nReturns true if the diffusion coefficient does not depend on the state of the process or time.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.createstruct-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.createstruct","text":"createstruct(abstract_type, name, params)\n\nCreate code that defines a struct defining a diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(p)\n\nFill all unspecified variables with default values\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Val{:additional},Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(::Val{:additional}, p)\n\nIf unspecified, there are no restriction on a state space, the volatility coefficient is assumed constant, the diffusion is not linear and the datatype of each coordinate is set to Float64.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Val{:dimensions},Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(::Val{:dimensions}, p)\n\nIf unspecified, the dimension of the stochastic process and the driving Brownian motion is set to 1.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.get_curly-Union{Tuple{Type{K}}, Tuple{K}} where K","page":"Index","title":"DiffusionDefinition.get_curly","text":"get_curly(::Type{K}) where K\n\nUtility function that returns a tuple with all type-specifiers listed in the curly brackets.\n\nExamples\n\njulia> remove_curly(Array{Float64,1})\n(:Float64, 1)\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.get_name_stem-Tuple{Symbol,Any}","page":"Index","title":"DiffusionDefinition.get_name_stem","text":"get_name_stem(name_stem::Symbol, parameters)\n\nGet the stem of a name for a parameters and then add a disambiguation index. Underscore _ used in place of name is defaulted to p.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.grad_y1-NTuple{5,Any}","page":"Index","title":"DiffusionDefinition.grad_y1","text":"grad_y1(y1, W, X, P, f)\n\nCompute ∇f with respect to the starting position y1 for a fixed Wiener path W. X is a container where the the trajectory computed for the Wiener path W under the law P will be stored.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.grad_θ-NTuple{6,Any}","page":"Index","title":"DiffusionDefinition.grad_θ","text":"grad_θ(θ, y1, W, X, Law, f)\n\nCompute ∇f with respect to parameters θ for a fixed Wiener path W. X is a container where the the trajectory computed for the Wiener path W under the law Law(θ) will be stored. y1 is the starting position.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.highest_idx_used-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.highest_idx_used","text":"highest_idx_used(name_stem, params)\n\nFind the highest disambiguation index that has been used thus far for a given name_stem.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.hypo_a_inv-Tuple{Any,Any,Any}","page":"Index","title":"DiffusionDefinition.hypo_a_inv","text":"hypo_a_inv(t, x, P)\n\nSimilar to a^-1=(σσ^T)^-1, with the only exception that all of the zero rows of σ are first removed to yield hatσ, and then, (hatσ hatσ^T)^-1 is computed.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.ignore_for_cu-Tuple{Val,Any}","page":"Index","title":"DiffusionDefinition.ignore_for_cu","text":"ignore_for_cu(::Val{T}, P) where T\n\nA flag to indicate that a parameter with name T has no contribution to the computation of conjugate updates.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.nonhypo-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.nonhypo","text":"nonhypo(x, P)\n\nReturn the diffusion's coordinates that have direct contribution from some non-degenerate Wiener terms, i.e. leave out coordinates whose Wiener term is zero.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.nonhypo_σ-Tuple{Float64,Any,Any}","page":"Index","title":"DiffusionDefinition.nonhypo_σ","text":"nonhypo_σ(t::Float64, x, P)\n\nReturn a sub-matrix of the full volatility matrix σ that consists of non-zero rows of σ.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.num_non_hypo-Tuple{Any}","page":"Index","title":"DiffusionDefinition.num_non_hypo","text":"num_non_hypo(Ptype::Type{T}) where T <: DiffusionProcess\n\nReturn a total number of coordinates of the diffusion process that have non-degenerate noise structure. I.e. it is equal to the total number of coordinates of the process minus the number of coordinates that have no direct Wiener contribution.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:additional},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:additional}, line, p)\n\nParse a line that defines additional information about a diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:aux_info},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:aux_info}, line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in a format:     name –> parameter-description\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:dimensions},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:dimensions}, line, p)\n\nParse a line that defines the dimension of a diffusion process and the driving Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Union{Tuple{K}, Tuple{K,Any,Any}} where K<:Union{Val{:parameters}, Val{:const_parameters}}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:parameters}, line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in a format:     name –> parameter-description\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_lines!-Tuple{Expr,Any,Any}","page":"Index","title":"DiffusionDefinition.parse_lines!","text":"parse_lines!(ex::Expr, p, condition)\n\nParse all lines of the expression ex, but process only those which satisfy condition. p is a passed-around structure that accumulates processed information.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_param_multi_names","page":"Index","title":"DiffusionDefinition.parse_param_multi_names","text":"parse_param_multi_names(line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in one of the formats:     (pname1, pname2, ...) –> (numberofparameters, datatype)     (pname1, pname2, ...) –> datatype     (pname1, pname2, ...) –> (datatype1, datatype2, ...) In the former two cases defines number_of_parameters-many parameters, with names p_name1, p_name2, ... and of datatype type. In the last case the datatypes differ from parameter to parameter.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.parse_param_single_name","page":"Index","title":"DiffusionDefinition.parse_param_single_name","text":"parse_param_single_name(line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in one of the formats:     parametername –> (numberofparameters, datatype)     parametername –> datatype In the former case defines number_of_parameters-many parameters, with names parameter_namei and of datatype type. In the latter case defines a single parameters with name parameter_name and of type datatype.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.parse_process-Tuple{Any,Expr,Any}","page":"Index","title":"DiffusionDefinition.parse_process","text":"parse_process(name , ex::Expr, ::Any)\n\nParse a template defining a diffusion process, create a corresponding struct and specified functions, evaluate them in the environment of a package and then import the struct name to Main scope, in which the package has been imported to.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.phi-Tuple{Val,Any,Any,Any}","page":"Index","title":"DiffusionDefinition.phi","text":"phi(::Val{T}, t, x, P) where T\n\nIf the drift can be written in a form:\n\nb_θ(t x) = θ^Tφ(tx)+ϕ(tx)\n\nfor parameters θ that are being updated, then phi is a row of the matrix φ(tx) that get's multiplied by the coordinate of a θ vector with a name T.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.prepare_abstract_type-NTuple{4,Any}","page":"Index","title":"DiffusionDefinition.prepare_abstract_type","text":"prepare_abstract_type(stem, dims, data_type, state_restr)\n\nCreate a string defining a parent, abstract type from its stem, the dimensions dims of the process and the driving Brownian motion, the datatype data_type of each coordinate and the restrictions on the state space state_restr.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.process_name","page":"Index","title":"DiffusionDefinition.process_name","text":"process_name\n\nProcess the name of a struct by returning the pure name (without template arguments), the name with template arguments and a list of template arguments.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.remove_curly-Union{Tuple{Type{K}}, Tuple{K}} where K","page":"Index","title":"DiffusionDefinition.remove_curly","text":"remove_curly(::Type{K}) where K\n\nUtility function that removes all type-specifiers listed in the curly brackets.\n\nExamples\n\njulia> remove_curly(Array{Float64,1})\nArray\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.set_parameters!-Tuple{DiffusionDefinition.DiffusionProcess,Any,Any}","page":"Index","title":"DiffusionDefinition.set_parameters!","text":"set_parameters!(P::DiffusionProcess, θ, entries)\n\nSet parameters of a diffusion law P in-place. entries should be a collection of pairs Pair{Int64,Symbol} that list the relevant entries in θ for reparameterization, together with the corresponding parameter names.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.update_label-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.update_label","text":"update_label(line, current_label)\n\nUpdate the label, which signifies what type of information a given line in a template is supposed to be encoding.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.β","page":"Index","title":"DiffusionDefinition.β","text":"β\n\nCompute vector β of a linear diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.β!","page":"Index","title":"DiffusionDefinition.β!","text":"β!\n\nCompute vector β! of a linear diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.σ","page":"Index","title":"DiffusionDefinition.σ","text":"σ\n\nCompute the volatility coefficient of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.σ!","page":"Index","title":"DiffusionDefinition.σ!","text":"σ!\n\nCompute the volatility coefficient of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#Random.rand!-Union{Tuple{D}, Tuple{K}, Tuple{T}, Tuple{Wiener{D,T} where T,Trajectory{T,Array{K,1}}}, Tuple{Wiener{D,T} where T,Trajectory{T,Array{K,1}},Any}} where D where K where T","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    w::Wiener{D},\n    path::Trajectory{T,Vector{K}},\n    y1=zero(K,D,ismutable(K))\n) where {T,K,D}\n\nSamples Wiener process started from y1 and saves the data in path. Uses a default random number generator.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Random.rand!-Union{Tuple{D}, Tuple{T}, Tuple{K}, Tuple{Random.AbstractRNG,Wiener{D,T} where T,Trajectory{T,#s26} where #s26<:(Array{#s27,1} where #s27<:(Array{K,N} where N))}, Tuple{Random.AbstractRNG,Wiener{D,T} where T,Trajectory{T,#s28} where #s28<:(Array{#s29,1} where #s29<:(Array{K,N} where N)),Any}} where D where T where K","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    rng::Random.AbstractRNG,\n    ::Wiener{D},\n    path::Trajectory{T,Vector{Vector{K}}},\n    y1=zeros(K,D)\n) where {K,T,D}\n\nSamples Wiener process with mutable states, started from y1 and saves the data in path. rng is used as a random number generator.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Random.rand!-Union{Tuple{K}, Tuple{T}, Tuple{Random.AbstractRNG,Wiener,Trajectory{T,#s23} where #s23<:Array{K,1}}, Tuple{Random.AbstractRNG,Wiener,Trajectory{T,#s24} where #s24<:Array{K,1},Any}} where K where T","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    rng::Random.AbstractRNG,\n    ::Wiener,\n    path::Trajectory{T,Vector{K}},\n    y1=zero(K)\n) where {T,K}\n\nSamples Wiener process with immutable states, started from y1 and saves the data in path. rng is used as a random number generator.\n\n\n\n\n\n","category":"method"},{"location":"#DiffusionDefinition.jl-1","page":"Home","title":"DiffusionDefinition.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a compact utility package for defining diffusion processes and sampling from their laws. It is created to work in conjunction with a suite of packages in JuliaDiffusionBayes that provide tools for Bayesian inference for diffusion processes. However, it can also be used on its own to:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"define diffusion laws\nforward-sample their trajectories\ncompute functionals of sampled paths\ncompute gradients of functionals of sampled paths with respect to diffusion parameters or with respect to the starting point of the trajectory","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of DiffusionDefinition.jl's main functionality see Get started.\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using DiffusionDefinition.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"},{"location":"predefined_processes/favetto_samson/#Favetto-Samson-compartment-model-1","page":"Favetto-Samson model","title":"Favetto-Samson compartment model","text":"","category":"section"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"Two dimensional SDE:","category":"page"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"beginsplit\ndd X_t = (αδ(t) - (α+β)X_t + μ Y_t)dd t + σ_1 dW^1_t\ndd Y_t = (λX_t - μ Y_t) dd t + σ2 dW^2_t\nendsplit","category":"page"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"Can be imported with","category":"page"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"@load_diffusion FavettoSamson","category":"page"},{"location":"predefined_processes/favetto_samson/#Example-1","page":"Favetto-Samson model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion FavettoSamson\nθ = [117, 5.83, 1.25, 1.5, 1.41, 0.0]\nP = FavettoSamson(θ..., t->2*(t/2)/(1+(t/2)^2))\ntt, y1 = 0.0:0.0001:10.0, @SVector [0.0, 0.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), size=(800, 300))","category":"page"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"(Image: favetto_samson)","category":"page"}]
}
