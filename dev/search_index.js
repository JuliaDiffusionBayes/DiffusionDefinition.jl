var documenterSearchIndex = {"docs":
[{"location":"examples/sine/#Sine-diffusion-1","page":"Sine diffusion","title":"Sine diffusion","text":"","category":"section"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"A simple, scalar diffusion process displaying multimodality on a path space. It solves the following stochastic differential equation","category":"page"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"dd X_t = (a + bsin(c X_t))dd t + sigma dd W_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"It can be called with","category":"page"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"@load_diffusion :Sine","category":"page"},{"location":"examples/sine/#Auxiliary-diffusion-1","page":"Sine diffusion","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"We define an additional, linear diffusion that can be used in the setting of guided proposals. It solves the following SDE","category":"page"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"dd widetildeX_t = left(fracx_T-x_0T + fract5TwidetildeX_tright)dd t + sigma dd W_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"and can be called with","category":"page"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"@load_diffusion :SineAux","category":"page"},{"location":"examples/sir/#Susceptible-Infectious-Recovered-model-1","page":"SIR model","title":"Susceptible-Infectious-Recovered model","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model","title":"SIR model","text":"A simple, scalar-valued susceptible-infectious-recovered (SIR) model defined by a two-dimension diffusion process solving the following SDE","category":"page"},{"location":"examples/sir/#","page":"SIR model","title":"SIR model","text":"beginalign*\ndd I_t = (alpha (1-I_t-R_t)I_t - beta I_t)dd t -sigma_1sqrt(1-I_t-R_t)I_t dd W^(1)_t - sigma_2sqrtI_tdd W^(2)_t\ndd R_t = beta I_t + sigma_2sqrtI_t dd W^(2)_t\nendalign*","category":"page"},{"location":"examples/sir/#","page":"SIR model","title":"SIR model","text":"with I_tin01 and R_tin01 for all tin0T. It can be called with:","category":"page"},{"location":"examples/sir/#","page":"SIR model","title":"SIR model","text":"@load_diffusion SIR","category":"page"},{"location":"examples/sir/#Auxiliary-diffusion-1","page":"SIR model","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model","title":"SIR model","text":"We additionally define a suitable linear process that can be used in the setting of guided proposals. It is a solution to the following SDE","category":"page"},{"location":"examples/sir/#","page":"SIR model","title":"SIR model","text":"beginalign*\ndd widetildeI_t = (alpha (1-widetildeI_t-widetildeR_t)widetildeI_t - beta widetildeI_t)dd t -sigma_1(1-widetildeI_t-widetildeR_t)widetildeI_t dd W^(1)_t - sigma_2widetildeI_tdd W^(2)_t\ndd widetildeR_t = beta widetildeI_t + sigma_2widetildeI_t dd W^(2)_t\nendalign*","category":"page"},{"location":"examples/sir/#","page":"SIR model","title":"SIR model","text":"and can be called with","category":"page"},{"location":"examples/sir/#","page":"SIR model","title":"SIR model","text":"@load_diffusion SIRAux","category":"page"},{"location":"examples/lotka_volterra/#Lotka-Volterra-1","page":"Lotka-Volterra system","title":"Lotka-Volterra","text":"","category":"section"},{"location":"examples/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"A simple, scalar-valued predator-prey model.","category":"page"},{"location":"examples/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"beginalign*\ndd X_t = (alpha X_t - beta X_t Y_t) dd t + sigma_1 dd W^(1)_t \ndd Y_t = (delta X_t Y_t -gamma Y_t)dd t + sigma_2 dd W^(2)_t\nendalign*","category":"page"},{"location":"examples/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"Can be called with","category":"page"},{"location":"examples/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"@load_diffusion :LotkaVolterra","category":"page"},{"location":"examples/lotka_volterra/#Auxiliary-diffusion-1","page":"Lotka-Volterra system","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"examples/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"We also provide a linear diffusion that is obtained from linearising SDE above at the equilibrium point. This process can be used as an auxiliary diffusion in the setting of guided proposals. It solves the following stochastic differential equation","category":"page"},{"location":"examples/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"beginalign*\ndd widetildeX_t = left(- fracbetagammadelta widetildeY_t + fracgammaalphadeltaright) dd t + sigma_1 dd W^(1)_t \ndd widetildeY_t = left(fracalphadeltabeta widetildeX_t-fracalphagammabetaright)dd t + sigma_2 dd W^(2)_t\nendalign*","category":"page"},{"location":"examples/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"and can be called with","category":"page"},{"location":"examples/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"@load_diffusion :LotkaVolterraAux","category":"page"},{"location":"examples/fitzhugh_nagumo/#FitzHugh-Nagumo-model-1","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A model developed to mimic the evolution of a neuron's membrane potential. Originally, it has been developed as a modification to the Van der Pol oscillator.","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Three parametrisations of the process are provided in this package.","category":"page"},{"location":"examples/fitzhugh_nagumo/#Regular-1","page":"FitzHugh-Nagumo model","title":"Regular","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Defined simply as FitzHughNagumo is a solution (Y,X) to the following stochastic differential equation:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = frac1epsilonleft( Y_t - Y_t^3-X_t + s right )dd t\ndd X_t = left( gamma Y_t - X_t + beta right )dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It can be called with","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumo","category":"page"},{"location":"examples/fitzhugh_nagumo/#Alternative-1","page":"FitzHugh-Nagumo model","title":"Alternative","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The stochastic differential equation above is re-parametrised in such a way that the first coordinate is given by the integrated second coordinate:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = dotY_t dd t\ndddotY_t = frac1epsilonleft( (1-gamma)Y_t -Y_t^3 -epsilon dotY_t + s - beta + left( 1-3Y_t^2 right)dotY_t right)dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The process (with name FitzHughNagumoAlt) can be called with","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAlt","category":"page"},{"location":"examples/fitzhugh_nagumo/#Conjugate-1","page":"FitzHugh-Nagumo model","title":"Conjugate","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to alternative parametrisation above, the only difference being that an additional step is taken of redefining the parameters:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"sleftarrow fracsepsilonquad betaleftarrowfracbetaepsilonquad sigmaleftarrowfracsigmaepsilonquad gammaleftarrowfracgammaepsilonquad epsilonleftarrowfrac1epsilon","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"This results in the stochastic differential equation of the form:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = dotY_t dd t\ndddotY_t = left( (epsilon-gamma)Y_t -epsilon Y_t^3 -dotY_t + s - beta + epsilonleft( 1-3Y_t^2 right)dotY_t right)dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The diffusion (with a struct name FitzHughNagumoConjug) can be called with","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjug","category":"page"},{"location":"examples/fitzhugh_nagumo/#Auxiliary-diffusions-1","page":"FitzHugh-Nagumo model","title":"Auxiliary diffusions","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Additionally, we defined linear diffusions that can be taken as auxiliary processes in the setting of Guided proposals. For all of these definitions it is assumed that the target process is observed completely at discrete times. For other observation settings the auxiliary diffusions need to be defined by the user, but the definitions in this package may act as a guide on how to do it.","category":"page"},{"location":"examples/fitzhugh_nagumo/#For-regular-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For regular parametrisation","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A linear diffusion obtained by linearising regular definition of the FitzHugh-Nagumo diffusion at an end-point:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd widetildeY_t = frac1epsilonleft( left( 1-3y_T^2 right )widetildeY_t - widetildeX_t + s + 2y_T^3 right)dd t\nddwidetildeX_t = left( gamma widetildeY_t - widetildeX_t + beta right)dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It can be called with","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAux","category":"page"},{"location":"examples/fitzhugh_nagumo/#For-alternative-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For alternative parametrisation","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#Simple-1","page":"FitzHugh-Nagumo model","title":"Simple","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A pair: (I,B), where B is a scaled Brownian motion and I is an integrated B:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd I_t = B_tdd t\ndd B_t = fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAltAuxSimple","category":"page"},{"location":"examples/fitzhugh_nagumo/#Linearisation-at-the-end-point-1","page":"FitzHugh-Nagumo model","title":"Linearisation at the end-point","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A linear diffusion obtained by linearising alternative definition of the FitzHugh-Nagumo diffusion at an end-point. If only the first coordinate is observed the proposal takes a form:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 right )widetildeY_t +left( 1-epsilon-3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta right )right dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"On the other hand, if both coordinates are observed, the proposal is given by:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 - 6y_Tdoty_T right )widetildeY_t +left( 1-epsilon -3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta + 6y_T^2doty_T right )right dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAltAuxLin","category":"page"},{"location":"examples/fitzhugh_nagumo/#For-conjugate-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For conjugate parametrisation","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#Simple-2","page":"FitzHugh-Nagumo model","title":"Simple","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A pair: (I,B), where B is a scaled Brownian motion and I is an integrated B:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd I_t = B_tdd t\ndd B_t = sigma dd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjugAuxSimple","category":"page"},{"location":"examples/fitzhugh_nagumo/#Linearisation-at-the-end-point-2","page":"FitzHugh-Nagumo model","title":"Linearisation at the end-point","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to FitzHughNagumoAltAuxLin, the only difference being that an additional step is taken of redefining the parameters (just as it was done in FitzHughNagumoConjug above). Consequently it is the solution to:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = left left epsilonleft(1-3y_T^2 - 6y_Tdoty_T right )-gamma right widetildeY_t +left epsilonleft( 1-3y_T^2 right)-1 right widetildeX_t + leftepsilonleft(2y_T^3+ 6y_T^2doty_T right ) +s-beta rightright dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"and can be called with","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjugAuxLin","category":"page"},{"location":"examples/prokaryote/#Prokaryotic-autoregulatory-gene-network-1","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"","category":"section"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"Chemical Langevin equation for a simple system describing production of a protein that is repressing its own production. The process under consideration is a 4-dimensional diffusion driven by an 8-dimensional Wiener process. The stochastic differential equation takes a form:","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":" dd X_t = Slefttheta circ h(X_t)rightdd t + Sodot gamma(thetacirc h(X_t)) dd W_t","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"where circRR^dto RR^d is a component-wise multiplication:","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(mu circ nu)_i = mu_inu_iquad i=1dotsd","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"the custom operation odotRR^dtimes dtoRR^dtimes d is defined via:","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(Modot mu)_ij = M_ijmu_jquad i=1dotsd j=1dotsd","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"the function gammaRR^dto RR^d is a component-wise square root:","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(gamma(mu))_i=sqrtmu_iquad i=1dotsd","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"S is the stoichiometry matrix:","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"S=left\n  beginmatrix\n  0  0  1  0  0  0  -1  0 \n  0  0  0  1  -2  2  0  -1 \n  -1  1  0  0  1  -1  0  0 \n  -1  1  0  0  0  0  0  0\n  endmatrix\nright","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"and the function h is given by:","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"h(x) = (x_3x_4 K-x_4 x_4 x_1 x_2(x_2-1)2 x_3 x_1 x_2)^T","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"The chemical Langevin equation above has been derived as an approximation to a chemical reaction network","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"beginalign*\nmathcalR_1textttDNA + textttP_2rightarrowtextttDNAcdottextttP_2\nmathcalR_2textttDNAcdottextttP_2rightarrowtextttDNA+textttP_2\nmathcalR_3textttDNArightarrowtextttDNA+textttRNA\nmathcalR_4textttRNArightarrowtextttRNA+textttP\nmathcalR_52textttPrightarrowtextttP_2\nmathcalR_6textttP_2rightarrow 2textttP\nmathcalR_7textttRNArightarrowemptyset\nmathcalR_8textttPrightarrowemptyset\nendalign*","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"with reactant constants given by the vector theta.","category":"page"},{"location":"examples/prokaryote/#Auxiliary-diffusion-1","page":"Prokaryotic autoregulatory gene network","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"We additionally define a linear diffusion that can be used in the setting of guided proposals. It is defined as a solution to the following SDE:","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"...","category":"page"},{"location":"examples/lorenz63/#Lorenz-'63-system-1","page":"Lorenz63 system","title":"Lorenz '63 system","text":"","category":"section"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"Famous Lorenz attractor, a three-dimensional elliptic diffusion, a solution to the following stochastic differential equation","category":"page"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"beginalign*\ndd X_t = theta_1 (Y_t - X_t) dd t + sigma dd W^(1)_t \ndd Y_t = X_t (theta_2 - Z_t) - Y_tdd t + sigma dd W^(2)_t\ndd Z_t = X_t Y_t - theta_3 Z_tdd t + sigma dd W^(3)_t\nendalign*","category":"page"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"Can be imported with the following command","category":"page"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"@load_diffusion :Lorenz","category":"page"},{"location":"examples/lorenz63/#Auxiliary-diffusion-1","page":"Lorenz63 system","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"We additionally provide an implementation of a linear diffusion that can be used in a setting of guided proposals. It is defined as a solution to the following SDE:","category":"page"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"beginalign\ndd wtX_t = left-theta_1 wtX_t + theta_2wtY_trightdd t + sigma dd W^(1)_t\ndd wtY_t = left (theta_2-z_T)wtX_t - wtY_t - x_TwtZ_t + x_Tz_T rightdd t + sigma dd W^(2)_t\ndd wtZ_t = left y_TwtX_t x_TwtX_t -theta_3wtZ_t -x_Ty_T rightdd t + sigma dd W^(3)_t\nendalign","category":"page"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"It can be called with","category":"page"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"@load_diffusion :LorenzAux","category":"page"},{"location":"overview/defining_diffusions/#Defining-diffusion-1","page":"Defining diffusions","title":"Defining diffusion","text":"","category":"section"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The main utility macro introduced in this package is @diffusion_process. It facilitates very concise definitions of structs characterising diffusion processes.","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"There are two (optionally three, third is not used now) parts expected by the macro:","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"the name of the diffusion (which may contain template parameters in the curly brackets)\nand the recipe for defining a struct\n(the third one, not used for now, we denote as POSTVARIABLES):","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"@diffusion_process NAME{TEMPLATE_PARAMETERS} begin\n  RECIPE\nend POSTVARIABLES","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"the snippet of code above creates a struct named NAME according to specifications listed in the RECIPE.","category":"page"},{"location":"overview/defining_diffusions/#Customisation-of-a-struct-1","page":"Defining diffusions","title":"Customisation of a struct","text":"","category":"section"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The RECIPE may contain information pertinent to four distinct categories:","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Specification of :dimensions\nSpecification of :parameters (their names and datatypes)\nSpecification of :conjugate updates\n:additional information","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Each type needs to be announced to julia by starting the list with the corresponding Symbol (or QuoteNode).","category":"page"},{"location":"overview/defining_diffusions/#Example-1","page":"Defining diffusions","title":"Example","text":"","category":"section"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"It's best to look at a simple example. Consider the definition of a Lorenz system:","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"@diffusion_process Lorenz{T} begin\n    :dimensions\n    process --> 3\n    wiener --> 3\n\n    :parameters\n    _ --> (3, T)\n    σ --> Float64\n\n    :additional\n    constdiff --> true\nend","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The macro above expands to:","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"struct Lorenz{T} <: DiffusionProcess{Float64,3,3,UnboundedStateSpace()}\n    p1::T\n    p2::T\n    p3::T\n    σ::Float64\n    function Lorenz(p1::T, p2::T, p3::T, σ::Float64) where T\n        new{T}(p1, p2, p3, σ)\n    end\nend","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"which defines a parametric type Lorenz{T}, together with some handy auxiliary functions specific to any instance of Lorenz{T}. We may now instantiate the newly defined struct as in","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"lorenz_law_with_float_parameters = Lorenz(1.0, 2.0, 3.0, 0.2)\nlorenz_law_with_static_vector_parameters = Lorenz([rand(DD.ℝ{3}) for i in 1:3]..., 0.2)","category":"page"},{"location":"overview/defining_diffusions/#More-systematic-explanations-1","page":"Defining diffusions","title":"More systematic explanations","text":"","category":"section"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The following information can be specified when using @diffusion_process.","category":"page"},{"location":"overview/defining_diffusions/#:dimensions-1","page":"Defining diffusions","title":":dimensions","text":"","category":"section"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Specification of the dimension of the process and the dimension of the driving Brownian motion. Must be written in a format: process --> dimension OR wiener --> dimension (eg. process --> 4)","category":"page"},{"location":"overview/defining_diffusions/#:parameters-1","page":"Defining diffusions","title":":parameters","text":"","category":"section"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"List of all parameters that the law depends on. Must be in one of the following formats (anywhere, if the parameter-name is set to _ then uses default names based on a letter p):","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"single-parameter-name --> single-data-type (eg. σ --> Float64 or σ --> T (if T is a template argument) or _ --> Vector{Int32}). This defines a single parameter.\nsingle-parameter-name --> (multiple-data-types,) (eg. σ --> (Float64, Int64), _ --> (Int32, T)). This defines as many parameters as there are specified types and appends the names with numbers to disambiguate multiple parameters with the same names.\nsingle-parameter-name --> (number-of-parameters, data-type) (eg. σ --> (3, Float64)) defines number-of-parameters-many parameters of the same data type.\n(multiple-parameter-names,) --> single-data-type (eg. (α, β, γ) --> Int64) defines as many parameters as there are names specified and sets them to be of the same type.\n(multiple-parameter-names,) --> (multiple-data-types,) (eg. (α, β, γ) --> (Float64, Int64, T)) defines as many parameters as there are names specified (there should be an equal number of names as there are types) and sets them to be of corresponding type.","category":"page"},{"location":"overview/defining_diffusions/#:conjugate-1","page":"Defining diffusions","title":":conjugate","text":"","category":"section"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"This is a section need to be present if conjugate Gaussian updates are to be made in the setting of Bayesian inference. Three pieces of information can be specified:","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Function phi\nFunction nonhypo in a format nonhypo(x) --> non-smooth-coordinates-of-x which specifies which coordinates of x have non-degenerate noise on them.\nnum_non_hypo which specifies how many coordinates are with non-degenerate noise on them [TODO change to a simple count of nonhypo output length]","category":"page"},{"location":"overview/defining_diffusions/#:additional-1","page":"Defining diffusions","title":":additional","text":"","category":"section"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The additional information provides some additional decorators that helps the compiler use specialised functions when called on instances of corresponding diffusion processes. The following paramters can be specified","category":"page"},{"location":"overview/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"constdiff --> true (or false) depending on whether the volatility coefficient is independent from the state variable (false by default)\nlinear --> true (or false) to indicate that a diffusion has a linear structure (false by default).\nstatespace --> type-of-state-space-restrictions (eg. statespace --> UnboundedStateSpace()) indicates any restrictions made on the state-space of a diffusion process.\neltype --> type-of-parameter (eg. eltype --> Float64) disambiguate the parameter type in case multiple types are used. This is useful for automatic differentiation where the derivatives of only a subset of parameters are taken and it is the eltype of those parameters that is of interest.","category":"page"},{"location":"examples/jansen_rit/#Jansen-Rit-model-1","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"","category":"section"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"Neural Mass Model used to describe the EEG data. It is a six-dimensional diffusion process driven by a three-dimensional Wiener process that is a solution to the following stochastic differential equation","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"beginequation*\n    beginaligned\n        dd X_t = dot X_t dd t  \n        dd Y_t = dot Y_t dd t  \n        dd Z_t = dot Z_t dd t \n        dd dot X_t =   leftA a left(mu_x(t) + mboxSigm(Y_t - Z_t)right) - 2a dot X_t - a^2 X_tright d t + sigma_x dd W^(1)_t\n        dd dot Y_t =  leftA a left(mu_y(t) + C_2mboxSigm(C_1 X_t)right) - 2a dot Y_t - a^2 Y_tright d t + sigma_y dd W^(2)_t\n        dd dot Z_t =  leftB b left(mu_z(t) + C_4mboxSigm(C_3 X_t)right) - 2b dot Z_t - b^2 Z_tright dd t + sigma_z dd W^(3)_t\n    endaligned\nendequation*","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"with initial condition","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"(X_0Y_0Z_0 dot X_0 dot Y_0 dot Z_0)=(x_0y_0z_0 dot x_0 dot y_0 dot z_0) in RR^6","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"where","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"mboxSigm(x) = fracnu_max1 + e^r(v_0 - x)","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"and","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"mu_x(t) =mu_xqquad mu_y(t) =mu_y mu_z(t) =mu_z","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"and","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"C_1 = C quad C_2 = 08C quad C_4 = C_3 = 025C","category":"page"},{"location":"overview/load_diff/#Loading-diffusions-1","page":"Loading diffusions","title":"Loading diffusions","text":"","category":"section"},{"location":"overview/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"We provide definitions of many standard diffusion processes. To see a list of all available processes call","category":"page"},{"location":"overview/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"@load_diffusion","category":"page"},{"location":"overview/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"See the Examples for more detailed descriptions. To load a particular diffusion simply write: @load_diffusion DiffusionName. For instance:","category":"page"},{"location":"overview/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"@load_diffusion LotkaVolterraAux","category":"page"},{"location":"overview/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"Then the process can be instantiated:","category":"page"},{"location":"overview/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"α, β, γ, δ, σ1, σ2 = 2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.2, 0.3\nlotka_volterra = LotkaVolterraAux(\n    α, β, γ, δ, σ1, σ2,\n    0.0, 1.0, zero(DD.ℝ{2}), zero(DD.ℝ{2})\n)","category":"page"},{"location":"examples/lorenz96/#Lorenz-'96-system-1","page":"Lorenz96 system","title":"Lorenz '96 system","text":"","category":"section"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"A model of atmospheric convection where each coordinate of the D-dimensional process X corresponds to a position on a periodic lattice that is supposed to be a proxy for a latitude circle on Earth. The diffusion X is defined as a solution to the following system of SDEs:","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"dd X_t = leftleft(X^(i+1)_t-X^(i-2)_tright)X^(i-1)_t-X^(i)_t+Frightdd t + sigma_i dd W^(i)_tquad tin0Tquad X^(i)_0=x^(i)_0","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"with iin1dotsD a cycling  index. The process can be called with","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"@load_variable_diffusion :Lorenz96 D","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"where D is a positive integer, indicating chosen dimension.","category":"page"},{"location":"overview/sampling/#Sampling-diffusion-trajectories-1","page":"Sampling trajectories","title":"Sampling diffusion trajectories","text":"","category":"section"},{"location":"overview/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"This package extends the functionality of Random.rand! and Base.rand to sampling of trajectories of diffusion processes. This package does not deal with the most versatile implementation of the unconditioned SDE samplers (for that see DifferentialEquations.jl) or conditioned SDE samplers (for that see Bridge.jl). Here we provide only the necessary (and efficient) functionality required for imputing diffusion processes and conducting Bayesian inference for them.","category":"page"},{"location":"overview/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The containers for sampled trajectories are chosen to be instances of Trajectory from the package Trajectories.jl. The functions exported by Trajectories.jl are re-exported by package DiffusionDefinition.jl.","category":"page"},{"location":"overview/sampling/#Copied-from-readme:-1","page":"Sampling trajectories","title":"Copied from readme:","text":"","category":"section"},{"location":"overview/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"For instance, to sample a three-dimensional standard Brownian motion use:","category":"page"},{"location":"overview/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"const DD = DiffusionDefinition\ntt = collect(0.0:0.01:1.0)\nwiener_path = rand(tt, wiener(), zero(DD.ℝ{3}))","category":"page"},{"location":"overview/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The wiener path can then be used in an Euler-Maruyama scheme to compute a trajectory under a given diffusion law:","category":"page"},{"location":"overview/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"XX = trajectory(tt, DD.ℝ{3})\nP = Lorenz(28.0, 10.0, 8.0/3.0, 2.0)\nDD.solve!(XX, WW, P, zero(DD.ℝ{3}))","category":"page"},{"location":"post_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"post_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionDefinition]","category":"page"},{"location":"post_index/#DiffusionDefinition.AbstractBuffer","page":"Index","title":"DiffusionDefinition.AbstractBuffer","text":"AbstractBuffer{T} <: AbstractArray{T,1}\n\nTypes inheriting from AbstractBuffer define buffers used for various in-place computations. Each subtype MUST:\n\nhave a field data which is a one-dimensional vector with data\nprovide a constructor of the form: NAME{eltype}(dim1, dim2, ...)\n\nand it CAN:\n\nhave multiple fields that provide views or reshaped views to data\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.BoundedStateSpace","page":"Index","title":"DiffusionDefinition.BoundedStateSpace","text":"BoundedStateSpace{L,U} <: DiffusionStateSpace\n\nUpper and lower bounds imposed on the state-space of a diffusion process. L corresponds to lower bounds, U corresponds to upper bounds.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.LowerBoundedStateSpace","page":"Index","title":"DiffusionDefinition.LowerBoundedStateSpace","text":"LowerBoundedStateSpace{T,S,N} <: DiffusionStateSpace\n\nLower bounds imposed on the state-space of a diffusion process. T is used to list the indices that have lower-bound restrictions, S indicates the values of the lower-bounds, N is the total number of coordinates with lower-bound restrictions\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.UnboundedStateSpace","page":"Index","title":"DiffusionDefinition.UnboundedStateSpace","text":"UnboundedStateSpace <: DiffusionStateSpace\n\nNo restrictions imposed on the state-space of the process (i.e. ℝᵈ)\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.UpperBoundedStateSpace","page":"Index","title":"DiffusionDefinition.UpperBoundedStateSpace","text":"UpperBoundedStateSpace{T,S,N} <: DiffusionStateSpace\n\nUpper bounds imposed on the state-space of a diffusion process. T is used to list the indices that have upper-bound restrictions, S indicates the values of the upper-bounds, N is the total number of coordinates with upper-bound restrictions\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.Wiener","page":"Index","title":"DiffusionDefinition.Wiener","text":"struct Wiener{D}\nend\n\nA struct defining the Wiener process. D indicates the dimension of the process if it cannot be inferred from the DataType of the Trajectory. If the dimension can be inferred then it takes precedence over the value of D.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#Trajectories.trajectory-Tuple{Any,Type,Number}","page":"Index","title":"Trajectories.trajectory","text":"Trajectories.trajectory(tt, v::Type, D::Number)\n\nCreate a Trajectory with mutable states of dimension D along the time collection tt.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Trajectories.trajectory-Tuple{Any,Type}","page":"Index","title":"Trajectories.trajectory","text":"Trajectories.trajectory(tt, v::Type)\n\nCreate a Trajectory with immutable states along the time collection tt.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.@diffusion_process-Tuple{Any,Expr,Vararg{Any,N} where N}","page":"Index","title":"DiffusionDefinition.@diffusion_process","text":"diffusion_process(name, ex::Expr, p...)\n\nDefines a diffusion process according to a template described in the documentation of the github repository: https://github.com/mmider/DiffusionDefinition.jl\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.@load_diffusion-Tuple{Any}","page":"Index","title":"DiffusionDefinition.@load_diffusion","text":"load_diffusion(name)\n\nLoads the predefined diffusion process.\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.@load_diffusion-Tuple{}","page":"Index","title":"DiffusionDefinition.@load_diffusion","text":"load_diffusion()\n\nDisplays available choices of predefined diffusion processes that can be loaded\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.AbstractSDESolver","page":"Index","title":"DiffusionDefinition.AbstractSDESolver","text":"abstract type AbstractSDESolver end\n\nSupertype of flags indicating ODE solvers\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.DiffusionProcess","page":"Index","title":"DiffusionDefinition.DiffusionProcess","text":"DiffusionProcess{T,DP,DW}\n\nTypes inheriting from DiffusionProcess define Ito diffusions. T denotes the datatype of each coordinate, DP the dimension of the stochastic process, DW the dimension of the Wiener process, SS lists the state space restrictions.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.DiffusionStateSpace","page":"Index","title":"DiffusionDefinition.DiffusionStateSpace","text":"DiffusionDomain\n\nTypes inheriting from DiffusionStateSpace define the types of restrictions put on the state-space of the stochastic process.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.EulerMaruyama","page":"Index","title":"DiffusionDefinition.EulerMaruyama","text":"struct EulerMaruyama <: AbstractSDESolver end\n\nFlag for indicating use of the Euler-Maruyama scheme for sampling diffusions. IMPORTANT: this is the only diffusion path sampler implemented in this package. There are no plans for implementing any other SDE solver in the forseeable future.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.LinearDiffBuffer","page":"Index","title":"DiffusionDefinition.LinearDiffBuffer","text":"struct LinearDiffBuffer{T,D,Tb,TB,Tσ,Tdw} <: AbstractBuffer{T}\n    data::Vector{T}\n    b::Tb\n    B::TB\n    σ::Tσ\n    dW::Tdw\nend\n\nA buffer for Euler-Maruyama simulations of linear diffusions. Almost the same as StandardEulerBuffer, but contains additional space for an intermediate construction of a matrix B (and a corrsponding view).\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.LinearDiffusion","page":"Index","title":"DiffusionDefinition.LinearDiffusion","text":"LinearDiffusion{T,DP,DW,SS} <: DiffusionProcess{T,DP,DW,SS}\n\nTypes inheriting from LinearDiffusion define a linear Ito-type diffusion, i.e. solutions to stochastic differential equations of the form: dXₜ = (BₜXₜ + βₜ)dt + σₜdWₜ, t∈[0,T], X₀=x₀.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.StandardEulerBuffer","page":"Index","title":"DiffusionDefinition.StandardEulerBuffer","text":"struct StandardEulerBuffer{T,D,Tb,Tσ,Tdw} <: AbstractBuffer{T}\n    data::Vector{T}\n    b::Tb\n    σ::Tσ\n    dW::Tdw\nend\n\nStandard buffer for the Euler-Maruyama simulations. The data is stored in data and b, σ, dW provide appropriately reshaped views to the corresponding segments of data. T is the DataType of each data element and D are dimensions needed to create the views.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#Base.Unicode.lowercase-Tuple{Symbol}","page":"Index","title":"Base.Unicode.lowercase","text":"Base.lowercase(s::Symbol)\n\nLowercase all letters in a symbol\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Base.eltype-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS where DW where DP}, Tuple{T}} where T","page":"Index","title":"Base.eltype","text":"Base.eltype(::DiffusionProcess{T}) where T = T\n\nReturn the datatype that each coordinate of the stochastic process is stored in.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Base.rand-Tuple{Any,Wiener,Any}","page":"Index","title":"Base.rand","text":"Base.rand(tt, w::Wiener, y1)\n\nSamples Wiener process on tt, started from y1 and returns a new object with a sampled trajectory.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Base.zero","page":"Index","title":"Base.zero","text":"Base.zero(K::Type, D, ::Val)\n\nIf K is a mutable type, then create zeros of dimension D and entries with types eltype(K). Otherwise, calls regular zero(K).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.B","page":"Index","title":"DiffusionDefinition.B","text":"B\n\nCompute matrix B of a linear diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.B!","page":"Index","title":"DiffusionDefinition.B!","text":"B!\n\nCompute matrix B of a linear diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition._is_datatype-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition._is_datatype","text":"_is_datatype(sym, p)\n\nUtility function that checks whether sym is a datatype. It returns true if sym is either an in-built datatype (say float, StaticArray etc.) or if it is a template argument.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(::Any, ::Any)\n\nReturn false by default i.e. if the first argument is not a symbol nor its quote\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{QuoteNode,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(s::QuoteNode, symbols)\n\nCheck if quote of a symbol s is listed in a list of symbols symbols\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{Symbol,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(s::Symbol, symbols)\n\nCheck if symbol s is listed in a list of symbols symbols\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.a","page":"Index","title":"DiffusionDefinition.a","text":"a\n\nCompute the diffusion function σσ' of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.a!","page":"Index","title":"DiffusionDefinition.a!","text":"a!\n\nCompute the diffusion function σσ' of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.add_constdiff_function!-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.add_constdiff_function!","text":"add_constdiff_function!(fns, p)\n\nAdd a definition of a function consdiff that indicates if the diffusion coefficient is constant\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.add_nonhypo_function!-Tuple{Any,Any,Any}","page":"Index","title":"DiffusionDefinition.add_nonhypo_function!","text":"add_nonhypo_function!(fns, line, p)\n\nAdd a definition of a function nonhypo that takes a current diffusion state x and returns the elliptic coordinates.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.add_phi_function!-Tuple{Expr,Array{Expr,1},Symbol,Symbol,Any}","page":"Index","title":"DiffusionDefinition.add_phi_function!","text":"add_phi_function!(expr::Expr, fns::Vector{Expr}, t::Symbol, x::Symbol, p)\n\nConstruct a phi function used for conjugate updates.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.b","page":"Index","title":"DiffusionDefinition.b","text":"b\n\nCompute the drift of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.b!","page":"Index","title":"DiffusionDefinition.b!","text":"b!\n\nCompute the drift of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.bound_satisfied-Tuple{UnboundedStateSpace,Any}","page":"Index","title":"DiffusionDefinition.bound_satisfied","text":"bound_satisfied(::UnboundedStateSpace, x)\n\nNo restrictions, bounds satisfied by default\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.bound_satisfied-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{LowerBoundedStateSpace{T,S,N},Any}} where N where S where T","page":"Index","title":"DiffusionDefinition.bound_satisfied","text":"bound_satisfied(::LowerBoundedStateSpace{T,S,N}, x) where {T,S,N}\n\nChecks if all coordinates adhere to lower bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.bound_satisfied-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{UpperBoundedStateSpace{T,S,N},Any}} where N where S where T","page":"Index","title":"DiffusionDefinition.bound_satisfied","text":"bound_satisfied(::UpperBoundedStateSpace{T,S,N}, x) where {T,S,N}\n\nChecks if all coordinates adhere to upper bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.bound_satisfied-Union{Tuple{U}, Tuple{L}, Tuple{BoundedStateSpace{L,U},Any}} where U where L","page":"Index","title":"DiffusionDefinition.bound_satisfied","text":"bound_satisfied(::BoundedStateSpace{L,U}, x) where {L,U}\n\nChecks if all coordinates adhere to lower and upper bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.cleanup_param_names!-Tuple{Any,Symbol,Symbol,Any}","page":"Index","title":"DiffusionDefinition.cleanup_param_names!","text":"cleanup_param_names!(expr, t::Symbol, x::Symbol, params)\n\nA hepler function for cleaning up the names of variables in the definition of a phi function.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.createstruct-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.createstruct","text":"createstruct(abstract_type, name, params)\n\nCreate code that defines a struct defining a diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.dimension-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS}, Tuple{DW}, Tuple{DP}, Tuple{T}} where DW where DP where T","page":"Index","title":"DiffusionDefinition.dimension","text":"dimension(::DiffusionProcess{T,DP,DW})\n\nReturn dimension of the stochastic process and driving Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.dimensions-Union{Tuple{Type{K}}, Tuple{K}} where K<:AbstractBuffer","page":"Index","title":"DiffusionDefinition.dimensions","text":"dimensions(::Type{K}) where K<:_AB\n\nUtility function for structs inheriting from AbstractBuffer. Returns the dimensions required for constructing the internal views of the data.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(p)\n\nFill all unspecified variables with default values\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Val{:additional},Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(::Val{:additional}, p)\n\nIf unspecified, there are no restriction on a state space, the volatility coefficient is assumed constant, the diffusion is not linear and the datatype of each coordinate is set to Float64.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Val{:dimensions},Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(::Val{:dimensions}, p)\n\nIf unspecified, the dimension of the stochastic process and the driving Brownian motion is set to 1.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.get_curly-Union{Tuple{Type{K}}, Tuple{K}} where K","page":"Index","title":"DiffusionDefinition.get_curly","text":"get_curly(::Type{K}) where K\n\nUtility function that returns a tuple with all type-specifiers listed in the curly brackets.\n\nExamples\n\njulia> remove_curly(Array{Float64,1})\n(:Float64, 1)\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.get_name_stem-Tuple{Symbol,Any}","page":"Index","title":"DiffusionDefinition.get_name_stem","text":"get_name_stem(name_stem::Symbol, parameters)\n\nGet the stem of a name for a parameters and then add a disambiguation index. Underscore _ used in place of name is defaulted to p.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.highest_idx_used-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.highest_idx_used","text":"highest_idx_used(name_stem, params)\n\nFind the highest disambiguation index that has been used thus far for a given name_stem.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:additional},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:additional}, line, p)\n\nParse a line that defines additional information about a diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:conjugate},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:conjugate}, line, p)\n\nParse a line that defines conjugate updates.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:dimensions},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:dimensions}, line, p)\n\nParse a line that defines the dimension of a diffusion process and the driving Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:parameters},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:parameters}, line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in a format:     name –> parameter-description\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_lines!-Tuple{Expr,Any,Any}","page":"Index","title":"DiffusionDefinition.parse_lines!","text":"parse_lines!(ex::Expr, p, condition)\n\nParse all lines of the expression ex, but process only those which satisfy condition. p is a passed-around structure that accumulates processed information.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_param_multi_names-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.parse_param_multi_names","text":"parse_param_multi_names(line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in one of the formats:     (pname1, pname2, ...) –> (numberofparameters, datatype)     (pname1, pname2, ...) –> datatype     (pname1, pname2, ...) –> (datatype1, datatype2, ...) In the former two cases defines number_of_parameters-many parameters, with names p_name1, p_name2, ... and of datatype type. In the last case the datatypes differ from parameter to parameter.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_param_single_name-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.parse_param_single_name","text":"parse_param_single_name(line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in one of the formats:     parametername –> (numberofparameters, datatype)     parametername –> datatype In the former case defines number_of_parameters-many parameters, with names parameter_namei and of datatype type. In the latter case defines a single parameters with name parameter_name and of type datatype.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_process-Tuple{Any,Expr,Any}","page":"Index","title":"DiffusionDefinition.parse_process","text":"parse_process(name , ex::Expr, ::Any)\n\nParse a template defining a diffusion process, create a corresponding struct and specified functions, evaluate them in the environment of a package and then import the struct name to Main scope, in which the package has been imported to.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.prepare_abstract_type-NTuple{4,Any}","page":"Index","title":"DiffusionDefinition.prepare_abstract_type","text":"prepare_abstract_type(stem, dims, data_type, state_restr)\n\nCreate a string defining a parent, abstract type from its stem, the dimensions dims of the process and the driving Brownian motion, the datatype data_type of each coordinate and the restrictions on the state space state_restr.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.process_name","page":"Index","title":"DiffusionDefinition.process_name","text":"process_name\n\nProcess the name of a struct by returning the pure name (without template arguments), the name with template arguments and a list of template arguments.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.remove_curly-Union{Tuple{Type{K}}, Tuple{K}} where K","page":"Index","title":"DiffusionDefinition.remove_curly","text":"remove_curly(::Type{K}) where K\n\nUtility function that removes all type-specifiers listed in the curly brackets.\n\nExamples\n\njulia> remove_curly(Array{Float64,1})\nArray\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.solve!-NTuple{4,Any}","page":"Index","title":"DiffusionDefinition.solve!","text":"solve!(XX, WW, P, y1)\n\nCompute a trajectory, started from y1 and following the diffusion law P, from the sampled Wiener process WW. Save the sampled path in XX. Return prematurely with a false massage if the numerical scheme has led to the solver violating the state-space restrictions.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.solve!-NTuple{5,Any}","page":"Index","title":"DiffusionDefinition.solve!","text":"solve!(XX, WW, P, y1, buffer)\n\nSame as solve!(XX, WW, P, y1), but additionally provides a pre-allocated buffer for performing in-place computations.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.state_space-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS}}, Tuple{SS}, Tuple{DW}, Tuple{DP}, Tuple{T}} where SS where DW where DP where T","page":"Index","title":"DiffusionDefinition.state_space","text":"state_space(::DiffusionProcess{T,DP,DW,SS})\n\nReturn the state space restrictions.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.update_label-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.update_label","text":"update_label(line, current_label)\n\nUpdate the label, which signifies what type of information a given line in a template is supposed to be encoding.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.β","page":"Index","title":"DiffusionDefinition.β","text":"β\n\nCompute vector β of a linear diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.β!","page":"Index","title":"DiffusionDefinition.β!","text":"β!\n\nCompute vector β! of a linear diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.σ","page":"Index","title":"DiffusionDefinition.σ","text":"σ\n\nCompute the volatility coefficient of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.σ!","page":"Index","title":"DiffusionDefinition.σ!","text":"σ!\n\nCompute the volatility coefficient of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#Random.rand!-Union{Tuple{D}, Tuple{K}, Tuple{T}, Tuple{Trajectory{T,Array{K,1}},Wiener{D}}, Tuple{Trajectory{T,Array{K,1}},Wiener{D},Any}} where D where K where T","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    path::Trajectory{T,Vector{K}},\n    w::Wiener{D},\n    y1=zero(K,D,ismutable(K))\n) where {T,K,D}\n\nSamples Wiener process started from y1 and saves the data in path. Uses a default random number generator.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Random.rand!-Union{Tuple{D}, Tuple{T}, Tuple{K}, Tuple{Random.AbstractRNG,Trajectory{T,Array{Array{K,1},1}},Wiener{D}}, Tuple{Random.AbstractRNG,Trajectory{T,Array{Array{K,1},1}},Wiener{D},Any}} where D where T where K","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    rng::Random.AbstractRNG,\n    path::Trajectory{T,Vector{Vector{K}}},\n    ::Wiener{D},\n    y1=zeros(K,D)\n) where {K,T,D}\n\nSamples Wiener process with mutable states, started from y1 and saves the data in path. rng is used as a random number generator.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Random.rand!-Union{Tuple{K}, Tuple{T}, Tuple{Random.AbstractRNG,Trajectory{T,Array{K,1}},Wiener}, Tuple{Random.AbstractRNG,Trajectory{T,Array{K,1}},Wiener,Any}} where K where T","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    rng::Random.AbstractRNG,\n    path::Trajectory{T,Vector{K}},\n    ::Wiener,\n    y1=zero(K)\n) where {T,K}\n\nSamples Wiener process with immutable states, started from y1 and saves the data in path. rng is used as a random number generator.\n\n\n\n\n\n","category":"method"},{"location":"#DiffusionDefinition.jl-1","page":"Home","title":"DiffusionDefinition.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a small utility package for defining diffusion processes and sampling from their laws. It is created to work in conjunction with a suite of packages in JuliaDiffusionBayes to provide tools for Bayesian inference for diffusion processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To get started see how to define diffusion processes with this package","category":"page"}]
}
