var documenterSearchIndex = {"docs":
[{"location":"predefined_processes/prokaryote/#Prokaryotic-autoregulatory-gene-network-1","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"","category":"section"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"Chemical Langevin equation for a simple system describing production of a protein that is repressing its own production. The process under consideration is a 4-dimensional diffusion driven by an 8-dimensional Wiener process. The stochastic differential equation takes a form:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":" dd X_t = Slefttheta circ h(X_t)rightdd t + Sodot gamma(thetacirc h(X_t)) dd W_t","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"where circRR^dto RR^d is a component-wise multiplication:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(mu circ nu)_i = mu_inu_iquad i=1dotsd","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"the custom operation odotRR^dtimes dtoRR^dtimes d is defined via:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(Modot mu)_ij = M_ijmu_jquad i=1dotsd j=1dotsd","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"the function gammaRR^dto RR^d is a component-wise square root:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(gamma(mu))_i=sqrtmu_iquad i=1dotsd","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"S is the stoichiometry matrix:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"S=left\n  beginmatrix\n  0  0  1  0  0  0  -1  0 \n  0  0  0  1  -2  2  0  -1 \n  -1  1  0  0  1  -1  0  0 \n  -1  1  0  0  0  0  0  0\n  endmatrix\nright","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"and the function h is given by:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"h(x) = (x_3x_4 K-x_4 x_4 x_1 x_2(x_2-1)2 x_3 x_1 x_2)^T","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"The chemical Langevin equation above has been derived as an approximation to a chemical reaction network","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"beginalign*\nmathcalR_1textttDNA + textttP_2rightarrowtextttDNAcdottextttP_2\nmathcalR_2textttDNAcdottextttP_2rightarrowtextttDNA+textttP_2\nmathcalR_3textttDNArightarrowtextttDNA+textttRNA\nmathcalR_4textttRNArightarrowtextttRNA+textttP\nmathcalR_52textttPrightarrowtextttP_2\nmathcalR_6textttP_2rightarrow 2textttP\nmathcalR_7textttRNArightarrowemptyset\nmathcalR_8textttPrightarrowemptyset\nendalign*","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"with reactant constants given by the vector theta.","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"Can be imported with","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"@load_diffusion Prokaryote","category":"page"},{"location":"predefined_processes/prokaryote/#Example-1","page":"Prokaryotic autoregulatory gene network","title":"Example","text":"","category":"section"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion Prokaryote\nθ, K = [0.1, 0.7, 0.35, 0.2, 0.1, 0.9, 0.3, 0.1], 10.0\nP = Prokaryote(θ..., K)\ntt, y1 = 0.0:0.001:10.0, @SVector [8.0, 8.0, 8.0, 5.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), label=[\"RNA\" \"P\" \"P₂\" \"DNA\"], size=(800,300))","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"(Image: prokaryote)","category":"page"},{"location":"predefined_processes/prokaryote/#Auxiliary-diffusion-1","page":"Prokaryotic autoregulatory gene network","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"We additionally define a linear diffusion that can be used in the setting of guided proposals. It is defined as a solution to the following SDE:","category":"page"},{"location":"predefined_processes/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"...","category":"page"},{"location":"manual/functionals_of_paths/#Computing-path-functionals-when-sampling-1","page":"Computing path-functionals","title":"Computing path-functionals when sampling","text":"","category":"section"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"rand, rand! and solve! accept an additional, named argument f—a functional of a path. By default it is turned off, but we may define some Julia function and pass it on to rand, rand! or solve! to be evaluated during the call to solve!. For out-of-place computations three versions of function need to be defined:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"# called at the very start of solve!\nf_accum = foo(P, y)\n# called at the beginning of every iteration of the Euler-Maruyama scheme\nf_accum = foo(f_accum, P, y, t, dt, dW, i)\n# called at the very end, just before return statement\nf_accum = foo(f_accum, P, y, Val(:final))","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"For in-place computations these three functions must have a slightly different form","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"# called at the very start of solve!\nf_accum = foo(buffer, P, y) # the buffer needs to accommodate the needs of function f\n# called at the beginning of every iteration of the Euler-Maruyama scheme\nfoo(buffer, P, y, tt[i-1], dt, i-1)\n# called at the very end, just before return statement\nfoo(buffer, P, y, _FINAL)","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"If foo is appropriately defined, then we may pass it to, say, rand as follows:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"X, foo_result = rand(P, tt, y1; f=foo)","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"Then, the output of rand is not only the sampled path X, but also the result of evaluating the functional defined by foo.","category":"page"},{"location":"manual/functionals_of_paths/#Example-1","page":"Computing path-functionals","title":"Example","text":"","category":"section"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"As an example, consider computing:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"Y_0^3e^-frac1100int_0^T (Y_t^1)^2e^-tdd t + Y_T^2100 ","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"for Y a path drawn under the Lorenz law, and Y^i representing its ith coordinate. We may define functions foo as follows:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"foo(P::Lorenz, y) = log(y[3])\nfoo(f_accum, P::Lorenz, y, t, dt, dW, i) = f_accum - exp(-t)*y[1]^2/100.0*dt\nfoo(f_accum, P::Lorenz, y, ::Val{:final}) = exp(f_accum + y[2]/100.0)\nX, foo_result = rand(P, tt, y1; f=foo)","category":"page"},{"location":"manual/functionals_of_paths/#Gradients-of-path-functionals-when-sampling-1","page":"Computing path-functionals","title":"Gradients of path-functionals when sampling","text":"","category":"section"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"Why would we care about computing path-functionals at the time of sampling instead of simply doing so after the path has been sampled and stored in a Trajectory? The answer is: we can leverage Julia's automatic differentiation implemented in the package ForwardDiff.jl to compute gradients (and Hessians) of said functionals with respect to, say, a starting point or diffusion's parameters in a very efficient manner and without having to strain the memory by expanding the DataType used in Trajectory'ies.","category":"page"},{"location":"manual/functionals_of_paths/#Example-2","page":"Computing path-functionals","title":"Example","text":"","category":"section"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"For instance, in the example above, if we wanted to compute gradients with respect to diffusion parameters we can do the following:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"# need a wrapper around foo\nfunction foobar(θ)\n    P = Lorenz(θ...)\n    _, foo_result = DD.solve!(X, W, P, y1_θ; f=foo)\n    foo_result\nend\n# stating parameters\nθ° = @SVector[10.0, 28.0, 8.0/3.0, 1.0]\ntt = 0.0:0.001:10.0\ny1 = @SVector [-10.0, -10.0, 25.0]\nX, W = trajectory(P, tt)\nrand!(Wiener(), W)\n# gradient preparation\ny1_θ_type = similar_type(θ°, Dual{Tag{typeof(foobar),eltype(y1)},eltype(y1),length(θ)}, Size(y1))\ny1_θ = y1_θ_type(y1)\n\ngrad_at_θ° = ForwardDiff.gradient(foobar, θ°)","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"The trajectories X and W are of regular, default datatype specified by P (and do not use Duals from ForwardDiff). y1 needs to be already of the type that uses Dual numbers (that's how solve! knows what DataType to use).","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"The steps above are packaged in a convenience function","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"DiffusionDefinition.grad_θ","category":"page"},{"location":"manual/functionals_of_paths/#DiffusionDefinition.grad_θ","page":"Computing path-functionals","title":"DiffusionDefinition.grad_θ","text":"grad_θ(θ, y1, W, X, Law, f)\n\nCompute ∇f with respect to parameters θ for a fixed Wiener path W. X is a container where the the trajectory computed for the Wiener path W under the law Law(θ) will be stored. y1 is the starting position.\n\n\n\n\n\n","category":"function"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"so all the steps above are encapsulated by a call","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"# stating parameters\nθ° = @SVector[10.0, 28.0, 8.0/3.0, 1.0]\ntt = 0.0:0.001:10.0\ny1 = @SVector [-10.0, -10.0, 25.0]\nX, W = trajectory(P, tt)\nrand!(Wiener(), W)\n\n# gradient computation\ngrad_at_θ° = grad_θ(θ°, y1, W, X, Lorenz, foo)","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"Additionally, we provide:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"DiffusionDefinition.grad_y1","category":"page"},{"location":"manual/functionals_of_paths/#DiffusionDefinition.grad_y1","page":"Computing path-functionals","title":"DiffusionDefinition.grad_y1","text":"grad_y1(y1, W, X, P, f)\n\nCompute ∇f with respect to the starting position y1 for a fixed Wiener path W. X is a container where the the trajectory computed for the Wiener path W under the law P will be stored.\n\n\n\n\n\n","category":"function"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"so that gradients with respect to a starting position may be computed as follows:","category":"page"},{"location":"manual/functionals_of_paths/#","page":"Computing path-functionals","title":"Computing path-functionals","text":"P = Lorenz(θ°...)\nDD.grad_y1(y1, W, X, P, foo)","category":"page"},{"location":"how_to_guides/expect_of_gradient/#how_to_guides-1","page":"(TODO) How to compute expectation of gradients of functionals","title":"How to compute expected values of gradients of functionals","text":"","category":"section"},{"location":"manual/sampling/#Sampling-diffusion-trajectories-1","page":"Sampling trajectories","title":"Sampling diffusion trajectories","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"This package extends functions Random.rand! and Base.rand to sampling of trajectories of diffusion processes.","category":"page"},{"location":"manual/sampling/#Trajectories-1","page":"Sampling trajectories","title":"Trajectories","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The containers for sampled trajectories are instances of Trajectory from the package Trajectories.jl. The functions exported by Trajectories.jl are re-exported by this package. The most literal way of defining trajectories is to directly pass already initialized and sized containers (or iterators), for instance","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"tt = 0.0:0.01:1.0\nxx = [zeros(Float64, 10) for _ in tt]\npath = trajectory(tt, xx)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"However, we may also be more concise and let trajectory initialize the path containers for us:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"# for mutable types we need to pass DataType as well as dimension\npath_mutable = trajectory(tt, Vector{Float64}, 10)\n# for immutable types the dimension is inferred from the DataType\npath_mutable = trajectory(tt, SVector{10,Float64})","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Finally, if we are initializing containers for a specific diffusion, then we may utilize the default types defined for this law together with information about diffusion's dimensions. For instance:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"P = Lorenz(10.0, 28.0, 8.0/3.0, 1.0)\npaths = trajectory(tt, P)\nXX, WW = paths.process, paths.wiener","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Or optionally specify the types ourselves:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"P = Lorenz(10.0, 28.0, 8.0/3.0, 1.0)\npaths = trajectory(\n    tt,\n    P,\n    Vector{Float64}, # process DataType\n    Vector{Float64}, # Wiener DataType\n)\nX, W = paths.process, paths.wiener","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"note: Note\nYou can also define multiple trajectories at once by passing multiple time segments, for instancedt = 0.01\npaths = trajectory([0.0:dt:1.0, 1.0:dt:2.0, 2.0:dt:3.0], P)\n# XX below contains three trajectories and so does WW\nXX, WW = paths.process, paths.wiener","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"tip: Tip\nIf you need to call diffusion samplers multiple times (because you are using them, say, in an MCMC setting), then initializing trajectories once and passing them around to sampling functions will massively improve the overall performance of your algorithms. However, if all you want to do is sample the trajectory once or a couple of times, then you don't need to worry about initializing trajectories yourself and let it be done by the rand function.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The time vector and path vector can be inspected by accessing fields t and x respectively:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"_time, _path = XX.t, XX.x","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"See the README.md of Trajectories for more details regarding other functionality implemented for Trajectory'ies.","category":"page"},{"location":"manual/sampling/#Sampling-Wiener-process-1","page":"Sampling trajectories","title":"Sampling Wiener process","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"In this package sampling of diffusion paths is always done on the basis of sampling the Wiener process first, treating it as a driving Brownian motion and then solve!ing the trajectory of the process based on that. The simplest way of sampling a Wiener process is to call:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"y1 = ... # define a starting point\nW = rand(Wiener(), tt, y1)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The dimensions and DataType of the Wiener process's trajectory are going to be inferred from the starting point y1.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Most often however, we need to sample the standard Brownian motion. For that reason we may omit y1 and it will be initialized to zero. In this case rand will use information contained in the struct Wiener to infer the dimension and DataType, for instance:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"W = rand(Wiener(4, ComplexF64), tt)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"to sample a four-dimensional complex-valued Brownian motion (with Float64 complex numbers).","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"warning: Warning\nIf y1 is not specified the DataType of state space will be set to SVector by default. To change this default behaviour you must overwrite the zero function to:Base.zero(w::Wiener{D,T}) where {D,T} = zeros(T, D)say, to use Vectors instead.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Alternatively, to avoid implicit allocation of space by rand we may pass a pre-initialized Trajectory to rand!:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"rand!(Wiener(), W)\n# OR\nrand!(wiener(), W, y1) # The first letter in `Wiener()` may be capital or not","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Note that in this case there is no need to decorate Wiener with additional type and dimension information as it is automatically inferred from the Trajectory container.","category":"page"},{"location":"manual/sampling/#Sampling-diffusion-processes-1","page":"Sampling trajectories","title":"Sampling diffusion processes","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The simplest way of sampling a diffusion trajectory is to call:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"P = Lorenz(10.0, 28.0, 8.0/3.0, 1.0)\ny1 = ... # define a starting point\ntt = 0.0:0.001:10.0\nX = rand(P, tt, y1)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"The type used for states is going to be inferred from the starting point and the dimensions of the Wiener and diffusion processes will be inferred from P. The decision about in-place vs out-of-place computation will be made based on the inferred type.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"note: Note\ny1 can also be left unspecified, then, the trajectory will start from zero and the default diffusion type of P will be used. Nonetheless, for many diffusion laws starting from zero might not make much sense, so this use is discouraged.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"rand for diffusions is a convenience function that wraps:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"initialization of trajectories X and W for the diffusion and Wiener paths respectively\nsampling Wiener path W\nsolve!ing the path X from the driving Brownian motion based on the Euler-Maruyama scheme.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"If you care about performance issues—say X needs to be re-sampled multiple times—then you might want to perform these steps by hand. I.e.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"# initialize containers:\nX, W = trajectory(tt, P)\ny1 = @SVector [-10.0, -10.0, 25.0]\n# sample Wiener path:\nrand!(Wiener(), W)\n# solve for the process trajectory\nDD.solve!(X, W, P, y1) # additionally pass `buffer` for in-place computations","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"Calling rand! and DD.solve! over and over again is much quicker than calling rand multiple times.","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"tip: Tip\nrand and rand! functions by default use the default pseudo-random number generator from the package Random.jl. If you wish to use your own pseudo-random number generator then pass it as an additional first argument, for instance: rand(RNG, Wiener(), tt).","category":"page"},{"location":"manual/sampling/#Plotting-the-results-1","page":"Sampling trajectories","title":"Plotting the results","text":"","category":"section"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"We provide plotting recipes for the Trajectory objects, so the plot function can be used to visualize the sampled trajectories very easily. Pass Val(:vs_time) to plot multiple (or single) trajectories vs time variable. Pass Val(:x_vs_y) to plot two coordinates against each other. Specify coordinates with a named argument coords. Otherwise, decorate your plots as you would otherwise by calling a plot function. For instance, to plot X[1] against X[3] call:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"using Plots\nplot(X, Val(:x_vs_y); coords=[1,3])","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"(Image: lorenz_x_vs_y)","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"To plot all coordinates against time call:","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"plot(X, Val(:vs_time))","category":"page"},{"location":"manual/sampling/#","page":"Sampling trajectories","title":"Sampling trajectories","text":"(Image: lorenz_vs_time)","category":"page"},{"location":"manual/convenience_functions/#utility_functions-1","page":"Utility functions","title":"Auto-generated utility functions","text":"","category":"section"},{"location":"manual/convenience_functions/#","page":"Utility functions","title":"Utility functions","text":"For each newly defined diffusion DiffusionProcess the package auto-generates some utility functions. They are not exported, but can be called by accessing through DiffusionDefinition module. These are:","category":"page"},{"location":"manual/convenience_functions/#","page":"Utility functions","title":"Utility functions","text":"Modules = [DiffusionDefinition]\nPages = [\"standard_functions.jl\"]","category":"page"},{"location":"manual/convenience_functions/#Base.eltype-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS where DW where DP}, Tuple{T}} where T","page":"Utility functions","title":"Base.eltype","text":"Base.eltype(::DiffusionProcess{T}) where T = T\n\nReturn the datatype that each coordinate of the stochastic process is stored in.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#Base.zero","page":"Utility functions","title":"Base.zero","text":"Base.zero(K::Type, D, ::Val)\n\nIf K is a mutable type, then create zeros of dimension D and entries with types eltype(K). Otherwise, calls regular zero(K).\n\n\n\n\n\n","category":"function"},{"location":"manual/convenience_functions/#Base.zero-Tuple{DiffusionDefinition.DiffusionProcess,Val{:process}}","page":"Utility functions","title":"Base.zero","text":"Base.zero(P::DiffusionProcess)\n\nInstantiate a zero element that can represent a state of a Brownian motion driving a diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#Base.zero-Tuple{DiffusionDefinition.DiffusionProcess,Val{:wiener}}","page":"Utility functions","title":"Base.zero","text":"Base.zero(P::DiffusionProcess)\n\nInstantiate a zero element that can represent a state of a diffusion.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.clone-Union{Tuple{T}, Tuple{T,Any,Any,Any,Val{:associate_by_name}}} where T<:DiffusionDefinition.DiffusionProcess","page":"Utility functions","title":"DiffusionDefinition.clone","text":"clone(\n    P::T, ξ, glob_to_loc, θ°idx, ::Val{:associate_by_name}\n) where T <: DiffusionProcess\n\nClone diffusion law P substituting relevant parameters with new values. ξ is a vector with parameters (possibly more than needed). ξ itself can be a subvector of a larger vector ξ°. The coordinates relevant for P are given in θ°idx and they refer to positions in the larger vector ξ°. The connection between coordinates in ξ° and ξ is given in glob_to_loc.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.const_parameter_names-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.const_parameter_names","text":"const_parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters that are considered to be constant.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.const_parameter_names-Tuple{Type{#s12} where #s12<:DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.const_parameter_names","text":"const_parameter_names(P::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters that are considered to be constant.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.const_parameters-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.const_parameters","text":"const_parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value. Return only those parameteres that are considered to be constant.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.default_type-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS where DW}, Tuple{DP}, Tuple{T}} where DP where T","page":"Utility functions","title":"DiffusionDefinition.default_type","text":"default_type(::DiffusionProcess{T,DP})\n\nAllows for inference of data type that encodes the state space of a given diffusion.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.default_wiener_type-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS}, Tuple{DW}, Tuple{DP}, Tuple{T}} where DW where DP where T","page":"Utility functions","title":"DiffusionDefinition.default_wiener_type","text":"default_wiener_type(::DiffusionProcess{T,DP,DW})\n\nAllows for inference of data type that encodes the state space of the Brownian motion driving a given diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.diagonalBmat-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.diagonalBmat","text":"diagonalBmat(P::DiffusionProcess)\n\nIndicator for whether the B matrix (if exists) is represented by a diagonal matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.diagonaldiff-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.diagonaldiff","text":"diagonaldiff(P::DiffusionProcess)\n\nIndicator for whether the volatility coefficient is represented by a diagonal matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.dimension-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS} where SS}, Tuple{DW}, Tuple{DP}, Tuple{T}} where DW where DP where T","page":"Utility functions","title":"DiffusionDefinition.dimension","text":"dimension(::DiffusionProcess{T,DP,DW})\n\nReturn dimension of the stochastic process and driving Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.end_point_info-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.end_point_info","text":"end_point_info(P::DiffusionProcess)\n\nReturn information about the end-point (works only if some information of this kind has been passed at the time of defining a struct) TODO improve\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.end_point_info_names-Tuple{Type{#s12} where #s12<:DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.end_point_info_names","text":"end_point_info_names(P::DiffusionProcess)\n\nReturn names of information pieces about the end-point (works only if some information of this kind has been passed at the time of defining a struct) TODO improve\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.parameter_names-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.parameter_names","text":"parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.parameter_names-Tuple{Type{#s13} where #s13<:DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.parameter_names","text":"parameter_names(::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.parameters-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.parameters","text":"parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.sparseBmat-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.sparseBmat","text":"sparseBmat(P::DiffusionProcess)\n\nIndicator for whether the B matrix (if exists) is represented by a sparse matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.sparsediff-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.sparsediff","text":"sparsediff(P::DiffusionProcess)\n\nIndicator for whether the volatility coefficient is represented by a sparse matrix\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.state_space-Union{Tuple{DiffusionDefinition.DiffusionProcess{T,DP,DW,SS}}, Tuple{SS}, Tuple{DW}, Tuple{DP}, Tuple{T}} where SS where DW where DP where T","page":"Utility functions","title":"DiffusionDefinition.state_space","text":"state_space(::DiffusionProcess{T,DP,DW,SS})\n\nReturn the state space restrictions.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.var_parameter_names-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.var_parameter_names","text":"var_parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters that are considered to be variable.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.var_parameter_names-Tuple{Type{#s12} where #s12<:DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.var_parameter_names","text":"var_parameter_names(P::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters that are considered to be variable.\n\n\n\n\n\n","category":"method"},{"location":"manual/convenience_functions/#DiffusionDefinition.var_parameters-Tuple{DiffusionDefinition.DiffusionProcess}","page":"Utility functions","title":"DiffusionDefinition.var_parameters","text":"var_parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value. Return only those parameteres that are considered to be variable.\n\n\n\n\n\n","category":"method"},{"location":"predefined_processes/lotka_volterra/#example_lotka_volterra-1","page":"Lotka-Volterra system","title":"Lotka-Volterra","text":"","category":"section"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"A simple, scalar-valued predator-prey model.","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"beginalign*\ndd X_t = (alpha X_t - beta X_t Y_t) dd t + sigma_1 dd W^(1)_t \ndd Y_t = (delta X_t Y_t -gamma Y_t)dd t + sigma_2 dd W^(2)_t\nendalign*","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"Can be called with","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"@load_diffusion LotkaVolterra","category":"page"},{"location":"predefined_processes/lotka_volterra/#Example-1","page":"Lotka-Volterra system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion LotkaVolterra\nθ = [2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.1, 0.1]\nP = LotkaVolterra(θ...)\ntt, y1 = 0.0:0.001:30.0, @SVector [2.0, 0.25]\nX = rand(P, tt, y1)\nplot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"(Image: lotka_volterra)","category":"page"},{"location":"predefined_processes/lotka_volterra/#Auxiliary-diffusion-1","page":"Lotka-Volterra system","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"We also provide a linear diffusion that is obtained from linearizing SDE above at the equilibrium point. This process can be used as an auxiliary diffusion in the setting of guided proposals. It solves the following stochastic differential equation","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"beginalign*\ndd widetildeX_t = left(- fracbetagammadelta widetildeY_t + fracgammaalphadeltaright) dd t + sigma_1 dd W^(1)_t \ndd widetildeY_t = left(fracalphadeltabeta widetildeX_t-fracalphagammabetaright)dd t + sigma_2 dd W^(2)_t\nendalign*","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"and can be called with","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"@load_diffusion :LotkaVolterraAux","category":"page"},{"location":"predefined_processes/lotka_volterra/#Example-2","page":"Lotka-Volterra system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion LotkaVolterraAux\nθ = [2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.1, 0.1]\nt, T, vT = 0.0, 1.0, nothing # dummy variables\nP = LotkaVolterraAux(θ..., t, T, vT)\ntt, y1 = 0.0:0.001:30.0, @SVector [2.0, 0.25]\nX = rand(P, tt, y1)\nplot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"(Image: lotka_volterra)","category":"page"},{"location":"predefined_processes/lotka_volterra/#","page":"Lotka-Volterra system","title":"Lotka-Volterra system","text":"note: Note\nNote that we had to pass additional variables t, T and vT even though they are immaterial to the auxiliary law. The reason for this is that we defined LotkaVolterraAux in such a way that it is already fully compatible with GuidedProposals.jl and may be passed as an auxiliary law (and auxiliary laws currently require presence of fields t, T and vT). However, in practice, when dealing with LotkaVolterraAux, the internal states of t, T and vT are never used.","category":"page"},{"location":"predefined_processes/lorenz96/#Lorenz-'96-system-1","page":"Lorenz96 system","title":"Lorenz '96 system","text":"","category":"section"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"A model of atmospheric convection where each coordinate of the D-dimensional process X corresponds to a position on a periodic lattice that is supposed to be a proxy for a latitude circle on Earth. The diffusion X is defined as a solution to the following system of SDEs:","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"dd X_t = leftleft(X^(i+1)_t-X^(i-2)_tright)X^(i-1)_t-X^(i)_t+Frightdd t + sigma_i dd W^(i)_tquad tin0Tquad X^(i)_0=x^(i)_0","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"with iin1dotsD a cycling  index. The process can be called with","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"@load_variable_diffusion :Lorenz96 D","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"where D is a positive integer, indicating chosen dimension.","category":"page"},{"location":"predefined_processes/lorenz96/#Example-1","page":"Lorenz96 system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"@load_variable_diffusion Lorenz96 2^10\nθ = [8.0, 1.0]\nP = Lorenz96(θ...)\ntt, y1 = 0.0:0.001:10.0, 9.0.*rand(SVector{2^10,Float64}).-3.0\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), coords=1:10, label=\"\", title=\"first 10 coordinates (out of 1024) vs time\")","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"(Image: lorenz96)","category":"page"},{"location":"predefined_processes/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"tip: Tip\nIf you've done the steps above on your laptop as well, you will have noticed how slow the compilation of the code above took. The reason is that StaticArrays are not designed to work for vectors of size 100+. For this reason it is much better to use in-place versions of samplers. This can be done by changing the default types and then starting from an appropriately changed starting point.const DD = DiffusionDefinition\nDD.default_type(::Lorenz96) = Vector{Float64}\nDD.default_wiener_type(::Lorenz96) = Vector{Float64}\ny1 = 9.0.*rand(2^10).-3.0\nX = rand(P, tt, y1)","category":"page"},{"location":"manual/defining_diffusions/#defining_diffusion-1","page":"Defining diffusions","title":"Defining diffusion","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The main utility macro introduced in this package is @diffusion_process. It facilitates very concise definitions of structs characterizing diffusion processes.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"There are two (optionally three) parts expected by the macro:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"the name of the diffusion (which, optionally, may contain template parameters in the curly brackets)\nand the recipe for defining a struct","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"@diffusion_process NAME{TEMPLATE_PARAMETERS} begin\n  RECIPE\nend","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"the snippet of code above creates a struct named NAME according to specifications listed in the RECIPE.","category":"page"},{"location":"manual/defining_diffusions/#Customisation-of-a-struct-1","page":"Defining diffusions","title":"Customisation of a struct","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The RECIPE may contain information pertinent to six distinct categories:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Specification of :dimensions\nSpecification of :parameters (their names and datatypes)\nSpecification of :constant_parameters (their names and datatypes)\nSpecification of :auxiliary_info\nSpecification of :conjugate updates (to be deprecated and substituted with something else)\n:additional information","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Each type needs to be announced to julia by starting the list with the corresponding Symbol (or QuoteNode).","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Note\nFor many users knowing only about :dimensions, :parameters and :additional will be sufficient and the other categories will not be of much importance.","category":"page"},{"location":"manual/defining_diffusions/#Lorenz_example-1","page":"Defining diffusions","title":"Example","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"It's best to look at a simple example. Consider the definition of a Lorenz system:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"@diffusion_process Lorenz{T} begin\n    :dimensions\n    process --> 3\n    wiener --> 3\n\n    :parameters\n    _ --> (3, T)\n    σ --> Float64\n\n    :additional\n    constdiff --> true\n    diagonaldiff --> true\nend","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The macro above expands to:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"struct Lorenz{T} <: DiffusionProcess{Float64, 3, 3, UnboundedStateSpace()}\n    p1::T\n    p2::T\n    p3::T\n    σ::Float64\n    function Lorenz(p1::T, p2::T, p3::T, σ::Float64) where T\n        new{T}(p1, p2, p3, σ)\n    end\n    function Lorenz(; p1::T, p2::T, p3::T, σ::Float64) where T\n        new{T}(p1, p2, p3, σ)\n    end\nend","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"which defines a parametric type Lorenz{T}, together with some handy auxiliary functions specific to any instance of Lorenz{T}. We may now instantiate the newly defined struct as in","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"P_f64 = Lorenz(10.0, 28.0, 8.0/3.0, 0.2)\nP_f32 = Lorenz(10.0f0, 28.0f0, 8.0f0/3.0f0, 0.2)","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"We can also call some functions that were auto-generated for the newly defined Lorenz struct, for instance","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"DD.parameter_names(Lorenz) == (:p1, :p2, :p3, :σ)\nDD.parameter_names(P_f64) == (:p1, :p2, :p3, :σ)\nDD.parameters(P_f64) == Dict(:p1 => 10.0, :p2 => 28.0, :p3 => 8.0/3.0, :σ => 0.2)","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"More functions are automatically defined in the background for each generated DiffusionProcess, to learn more about them see Convenience Functions.","category":"page"},{"location":"manual/defining_diffusions/#Systematic-explanations-1","page":"Defining diffusions","title":"Systematic explanations","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The following information can be specified in the definition of a diffusion law when calling a macro @diffusion_process.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"tip: Tip\nAll keywords read by @diffusion_process are case-insensitive.","category":"page"},{"location":"manual/defining_diffusions/#Category-1:-:dimensions-1","page":"Defining diffusions","title":"Category 1: :dimensions","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Specification of the dimension of the process and the dimension of the driving Brownian motion. Must be written in a format:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"process --> dimension OR\nwiener --> dimension (eg.\nprocess --> 4).","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"In both cases, if left unspecified then defaults to dimension=1.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\n:dimensions is not the only keyword that will be recognized by @diffusion_process as declaring the dimensions of the process. Alternative names that could be used in place of :dimensions are: :dim, :dims, :dimension","category":"page"},{"location":"manual/defining_diffusions/#Category-2:-:parameters-1","page":"Defining diffusions","title":"Category 2: :parameters","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"List of all parameters that the law depends on.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Note\n@diffusion_process understands _ as \"the user doesn't care about the name, so let's use a generic name based on the letter p and append it with a disambiguation number so that if there are more than one p's they are not confused with each other\"","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The parameters must be specified in one of the following formats:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"single-parameter-name --> single-data-type, (eg.\nσ --> Float64 or\nσ --> T (if T is one of the template's labels) or\n_ --> Vector{Int32}).\nThis defines a single parameter.\nsingle-parameter-name --> (multiple-data-types,) (eg.\nσ --> (Float64, Int64),\n_ --> (Int32, T)).\nThis defines as many parameters as there are specified types and appends the names with numbers to disambiguate multiple parameters with the same names.\nsingle-parameter-name --> (number-of-parameters, data-type) (eg.\nσ --> (3, Float64))\ndefines number-of-parameters-many parameters of the same data type.\n(multiple-parameter-names,) --> single-data-type (eg.\n(α, β, γ) --> Int64)\ndefines as many parameters as there are names specified and sets them to be of the same type.\n(multiple-parameter-names,) --> (multiple-data-types,) (eg.\n(α, β, γ) --> (Float64, Int64, T))\ndefines as many parameters as there are names specified (there should be an equal number of names as there are types, it will throw an AssertionError otherwise) and sets them to be of the corresponding type.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\n:parameters keyword alternatives: :param, :params","category":"page"},{"location":"manual/defining_diffusions/#Category-3:-:constant_parameters-1","page":"Defining diffusions","title":"Category 3: :constant_parameters","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"These can be defined in exactly the same way as :parameters. The only purpose for splitting the parameters into :constant_parameters and :parameters is to indicate to Julia that the set of all parameters may be split into two conceptually different groups. In particular, @diffusion_process defines utility functions that act differently with :constant_parameters and :parameters:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"DiffusionDefinition.parameters\nDiffusionDefinition.const_parameters\nDiffusionDefinition.var_parameters\nDiffusionDefinition.parameter_names\nDiffusionDefinition.const_parameter_names\nDiffusionDefinition.var_parameter_names","category":"page"},{"location":"manual/defining_diffusions/#DiffusionDefinition.parameters","page":"Defining diffusions","title":"DiffusionDefinition.parameters","text":"parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.const_parameters","page":"Defining diffusions","title":"DiffusionDefinition.const_parameters","text":"const_parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value. Return only those parameteres that are considered to be constant.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.var_parameters","page":"Defining diffusions","title":"DiffusionDefinition.var_parameters","text":"var_parameters(P::DiffusionProcess)\n\nReturn a tuple of pairs of parameter_name => parameter_value. Return only those parameteres that are considered to be variable.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.parameter_names","page":"Defining diffusions","title":"DiffusionDefinition.parameter_names","text":"parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters.\n\n\n\n\n\nparameter_names(::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.const_parameter_names","page":"Defining diffusions","title":"DiffusionDefinition.const_parameter_names","text":"const_parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters that are considered to be constant.\n\n\n\n\n\nconst_parameter_names(P::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters that are considered to be constant.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#DiffusionDefinition.var_parameter_names","page":"Defining diffusions","title":"DiffusionDefinition.var_parameter_names","text":"var_parameter_names(P::DiffusionProcess)\n\nReturn a tuple with the names of all paremeters that are considered to be variable.\n\n\n\n\n\nvar_parameter_names(P::Type{<:DiffusionProcess})\n\nReturn a tuple with the names of all paremeters that are considered to be variable.\n\n\n\n\n\n","category":"function"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Note\nThe split into constant and variable parameters is not done at a compile time and can also be done by hand after the struct with the diffusion has been constructed (though, it is discouraged). For instance, in the Lorenz example above we have:julia> DD.parameters(P_f64)\nDict{Symbol,Float64} with 4 entries:\n  :p2 => 28.0\n  :σ  => 0.2\n  :p1 => 10.0\n  :p3 => 2.66667\n\njulia> DD.const_parameters(P_f64)\nDict{Any,Any} with 0 entries\n\njulia> DD.var_parameters(P_f64)\nDict{Symbol,Float64} with 4 entries:\n  :p2 => 28.0\n  :σ  => 0.2\n  :p1 => 10.0\n  :p3 => 2.66667If we wanted to change our mind and define, say, :p1 and :p3 as constant parameters we could do that by overwriting the definition of the const_parameter_names(::Type{<:CustomDiffusionLaw}) method, as all other functions of this type are computed as a byproduct of parameter_names(::Type{<:CustomDiffusionLaw}) and const_parameter_names(::Type{<:CustomDiffusionLaw}) and the former one should never change.DD.const_parameter_names(::Type{<:Lorenz}) = (:p1, :p3)That's all that needs to be changed.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\n:constant_parameters keyword alternatives: const_parameters, :const_param, :const_params, :constparameters, :constparam, :constparams, :constant_param, :constant_params, :constantparameters, :constantparam, and :constantparams.","category":"page"},{"location":"manual/defining_diffusions/#Category-4:-:auxiliary_info-1","page":"Defining diffusions","title":"Category 4: :auxiliary_info","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Information about the end-points of the diffusion. This is a useful feature for guided proposals or simulation of diffusion bridges, where the process is conditioned to hit a certain end-point. In particular, it is used quite extensively in the package GuidedProposals.jl. The following fields can be defined:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"t0 (also accepts :t_0): the starting time-point\nT: the final time-point\nx0 (also accepts :y0, :state0, :x_0, :y_0, :state_0): the starting position\nv0 (also accepts :obs0, :v_0, :obs_0): the starting observation\nvT (also accepts :obsT, :v_T, :obs_T): the observation at the terminal time\nxT (also accepts :yT, :stateT, :x_T, :y_T, :state_T): the state of the process at the terminal time","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Each one of these fields can be defined in a format field-name --> field-type (e.g. T --> Float64).","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"warning: IMPORTANT\nIf at least one of the fields above is defined, then the field xT will be defined automatically and the diffusion constructor will default xT to a zero Vector (or SVector or Number, it will make a reasonable guess, but it may be wrong). The reason for this is to make employment of a blocking technique in other packages a bit easier.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\nauxiliary_info keyword alternatives: :aux_info, :end_points, :end_point_info","category":"page"},{"location":"manual/defining_diffusions/#Category-5:-:conjugate-1","page":"Defining diffusions","title":"Category 5: :conjugate","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"warning: Warning\nThis section will soon become deprecated and substituted with something more fitting.","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"This is a section that needs to be present if conjugate Gaussian updates are to be made in the setting of Bayesian inference in the package DiffusionMCMC.jl. Three pieces of information can be specified:","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"Function phi\nFunction nonhypo in a format nonhypo(x) --> non-smooth-coordinates-of-x which specifies which coordinates of x have non-degenerate noise on them.\nnum_non_hypo which specifies how many coordinates are with non-degenerate noise on them [TODO change to a simple count of nonhypo output length].","category":"page"},{"location":"manual/defining_diffusions/#Category-6:-:additional-1","page":"Defining diffusions","title":"Category 6: :additional","text":"","category":"section"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"The additional information provides some additional decorators that helps the compiler use specialized functions when called on instances of corresponding diffusion processes. The following information can be specified","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"constdiff --> true (or false) depending on whether the volatility coefficient is independent from the state variable (false by default).\nAlternative keywords: :constvola, :constdiffusivity, :constvolatility, :constσ, :constantdiff, :constantvola, :constantdiffusivity, :constantvolatility, :constantσ.\ndiagonaldiff --> true (or false) to indicate that the volatility coefficient is represented by a diagonal matrix (false by default).\nAlternative keywords: :diagonalvola, :diagonaldiffusivity, :diagonalvolatility, :diagonalσ, :diagdiff, :diagvola, :diagdiffusivity, :diagvolatility, :diagσ.\nsparsediff --> true (or false) to indicate that the volatility coefficient is a represented by a sparse matrix (false by default).\nAlternative keywords: :sparsevola, :sparsediffusivity, :sparsevolatility, :sparseσ.\nlinear --> true (or false) to indicate that a diffusion has a linear structure (false by default).\ndiagonalbmat --> true (or false) to indicate that a B matrix of a linear diffusion (with a drift b(x):=Bx+β) is diagonal (false by default).\nAlternative keywords: :diagonalb, :diagonalbmatrix.\nsparsebmat --> true (or false) to indicate that a B matrix of a linear diffusion (with a drift b(x):=Bx+β) is sparse (false by default).\nAlternative keywords: :sparseb, :sparsebmatrix.\nstatespace --> type-of-state-space-restrictions (eg. statespace --> UnboundedStateSpace()) indicates any restrictions made on the state-space of a diffusion process.\neltype --> type-of-parameter (eg. eltype --> Float64) disambiguate the parameter type in case multiple types are used. This is useful for automatic differentiation where the derivatives of only a subset of parameters are taken and it is the eltype of those parameters that is of interest. [TODO come back, not sure anymore if it has any use]","category":"page"},{"location":"manual/defining_diffusions/#","page":"Defining diffusions","title":"Defining diffusions","text":"note: Alternative keywords\n:additional keyword alternatives: :extra","category":"page"},{"location":"how_to_guides/higher_order_derivatives/#How-to-compute-higher-order-derivatives-of-functionals-1","page":"(TODO) How to compute higher order derivatives of functionals","title":"How to compute higher order derivatives of functionals","text":"","category":"section"},{"location":"get_started/package_overview/#get_started-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/DiffusionDefinition.jl","category":"page"},{"location":"get_started/package_overview/#Defining-the-process-1","page":"Get started","title":"Defining the process","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"To define a diffusion law use a macro @diffusion_process:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"using DiffusionDefinition\nconst DD = DiffusionDefinition\n\n@diffusion_process OrnsteinUhlenbeck begin\n    # :dimensions is optional, defaults both process and wiener to 1 anyway\n    :dimensions\n    process --> 1\n    wiener --> 1\n\n    :parameters\n    (θ, μ, σ) --> Float64\nend","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"This will define a struct OrnsteinUhlenbeck and announce to Julia that it represents a one-dimensional diffusion process driven by a one-dimensional Brownian motion and that it depends on 3 parameters of type Float64 each.","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"To complete characterization of a diffusion law we define the drift and diffusion coefficients:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"DD.b(t, x, P::OrnsteinUhlenbeck) = P.θ*(P.μ - x)\nDD.σ(t, x, P::OrnsteinUhlenbeck) = P.σ","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"We will also specify a default datatype for convenient definition of trajectories","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"DD.default_type(::OrnsteinUhlenbeck) = Float64\nDD.default_wiener_type(::OrnsteinUhlenbeck) = Float64","category":"page"},{"location":"get_started/package_overview/#Sampling-trajectories-under-the-diffusion-law-1","page":"Get started","title":"Sampling trajectories under the diffusion law","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"Use the function rand to sample the process","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"tt, y1 = 0.0:0.01:100.0, 0.0\nP = OrnsteinUhlenbeck(2.0, 0.0, 0.1)\nX = rand(P, tt, y1)","category":"page"},{"location":"get_started/package_overview/#Plotting-the-trajectories-1","page":"Get started","title":"Plotting the trajectories","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"Plotting may be done with any supported backend via function plot. Plotting recipes are provided which make sure that the output of rand (of the datatype trajectory) is understood by plot. For instance, to plot all diffusion coordinates (in case above only one) against the time variable write","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"using Plots\ngr()\nplot(X, Val(:vs_time))","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"(Image: ou_process)","category":"page"},{"location":"get_started/package_overview/#Repeated-sampling-1","page":"Get started","title":"Repeated sampling","text":"","category":"section"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"The package is implemented with the setting of Markov chain Monte Carlo methods in mind. Consequently, methods are built to be as efficient as possible under the setting of repeated sampling of trajectories. To fully leverage this speed you need to pre-allocate the containers for trajectories:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"X, W = trajectory(tt, P)","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"and then sample the process by:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"drawing the driving Brownian motion W,\nand then, solve!ing the path X from the Wiener path W","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"Wnr = Wiener()\nrand!(Wnr, W)\nDD.solve!(X, W, P, x0)","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"Sampling trajectories multiple times becomes very efficient then, for instance:","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"julia> using BenchmarkTools\njulia> @btime begin\n           for _ in 1:10^4\n               rand!(Wnr, W)\n               DD.solve!(X, W, P, x0)\n           end\n       end\n  1.840 s (10000 allocations: 156.25 KiB)","category":"page"},{"location":"get_started/package_overview/#","page":"Get started","title":"Get started","text":"i.e. 2s to sample 10 000 trajectories, each revealed on a time-grid with 10 001 points (tested on an Intel(R) Core(TM) i7-4600U CPU @ 2.10GHz). Note that sampling does only one allocation per call (which is due to return of a value by solve!).","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#FitzHugh-Nagumo-model-1","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A model developed to mimic the evolution of a neuron's membrane potential. Originally, it has been developed as a modification to the Van der Pol oscillator.","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Three parametrisations of the process are provided in this package.","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Regular-1","page":"FitzHugh-Nagumo model","title":"Regular","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Defined simply as FitzHughNagumo is a solution (Y,X) to the following stochastic differential equation:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = frac1epsilonleft( Y_t - Y_t^3-X_t + s right )dd t\ndd X_t = left( gamma Y_t - X_t + beta right )dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumo","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Example-1","page":"FitzHugh-Nagumo model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion FitzHughNagumo\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumo(θ...)\ntt, y1 = 0.0:0.001:30.0, @SVector [-0.9, -1.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), size=(800, 300))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_vs_time)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"plot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_x_vs_y)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Alternative-1","page":"FitzHugh-Nagumo model","title":"Alternative","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The stochastic differential equation above is re-parametrized in such a way that the first coordinate is given by the integrated second coordinate:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = dotY_t dd t\ndddotY_t = frac1epsilonleft( (1-gamma)Y_t -Y_t^3 -epsilon dotY_t + s - beta + left( 1-3Y_t^2 right)dotY_t right)dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The process (with name FitzHughNagumoAlt) can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAlt","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Example-2","page":"FitzHugh-Nagumo model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A parameterization equivalent to the above is then given by:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion FitzHughNagumoAlt\nθ = [0.1, -0.8, 1.5, 0.0, 0.3]\nP = FitzHughNagumoAlt(θ...)\ntt, y1 = 0.0:0.001:30.0, @SVector [-0.9, 0.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), size=(800, 300))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_vs_time)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"plot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_x_vs_y)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Conjugate-1","page":"FitzHugh-Nagumo model","title":"Conjugate","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to alternative parametrisation above, the only difference being that an additional step is taken of redefining the parameters:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"sleftarrow fracsepsilonquad betaleftarrowfracbetaepsilonquad sigmaleftarrowfracsigmaepsilonquad gammaleftarrowfracgammaepsilonquad epsilonleftarrowfrac1epsilon","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"This results in the stochastic differential equation of the form:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd Y_t = dotY_t dd t\ndddotY_t = left( (epsilon-gamma)Y_t -epsilon Y_t^3 -dotY_t + s - beta + epsilonleft( 1-3Y_t^2 right)dotY_t right)dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The diffusion (with a struct name FitzHughNagumoConjug) can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjug","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Example-3","page":"FitzHugh-Nagumo model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A parameterization equivalent to the above is then given by:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion FitzHughNagumoConjug\nθ = [10.0, -8.0, 15.0, 0.0, 3.0]\nP = FitzHughNagumoConjug(θ...)\ntt, y1 = 0.0:0.001:30.0, @SVector [-0.7, 0.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), size=(800, 300))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_vs_time)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"plot(X, Val(:x_vs_y))","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"(Image: fitzhugh_nagumo_x_vs_y)","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Auxiliary-diffusions-(TODO-the-code-won't-execute-correctly)-1","page":"FitzHugh-Nagumo model","title":"Auxiliary diffusions (TODO the code won't execute correctly)","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Additionally, we defined linear diffusions that can be taken as auxiliary processes in the setting of Guided proposals. For all of these definitions it is assumed that the target process is observed completely at discrete times. For other observation settings the auxiliary diffusions need to be defined by the user, but the definitions in this package may act as a guide on how to do it.","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#For-regular-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For regular parametrisation","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A linear diffusion obtained by linearising regular definition of the FitzHugh-Nagumo diffusion at an end-point:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd widetildeY_t = frac1epsilonleft( left( 1-3y_T^2 right )widetildeY_t - widetildeX_t + s + 2y_T^3 right)dd t\nddwidetildeX_t = left( gamma widetildeY_t - widetildeX_t + beta right)dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAux","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#For-alternative-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For alternative parametrisation","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#Simple-1","page":"FitzHugh-Nagumo model","title":"Simple","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A pair: (I,B), where B is a scaled Brownian motion and I is an integrated B:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd I_t = B_tdd t\ndd B_t = fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAltAuxSimple","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Linearisation-at-the-end-point-1","page":"FitzHugh-Nagumo model","title":"Linearisation at the end-point","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A linear diffusion obtained by linearising alternative definition of the FitzHugh-Nagumo diffusion at an end-point. If only the first coordinate is observed the proposal takes a form:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 right )widetildeY_t +left( 1-epsilon-3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta right )right dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"On the other hand, if both coordinates are observed, the proposal is given by:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 - 6y_Tdoty_T right )widetildeY_t +left( 1-epsilon -3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta + 6y_T^2doty_T right )right dd t + fracsigmaepsilondd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoAltAuxLin","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#For-conjugate-parametrisation-1","page":"FitzHugh-Nagumo model","title":"For conjugate parametrisation","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#Simple-2","page":"FitzHugh-Nagumo model","title":"Simple","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"A pair: (I,B), where B is a scaled Brownian motion and I is an integrated B:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndd I_t = B_tdd t\ndd B_t = sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"Can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjugAuxSimple","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#Linearisation-at-the-end-point-2","page":"FitzHugh-Nagumo model","title":"Linearisation at the end-point","text":"","category":"section"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to FitzHughNagumoAltAuxLin, the only difference being that an additional step is taken of redefining the parameters (just as it was done in FitzHughNagumoConjug above). Consequently it is the solution to:","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nddwidetildeY_t = widetildeX_t dd t\nddwidetildeX_t = left left epsilonleft(1-3y_T^2 - 6y_Tdoty_T right )-gamma right widetildeY_t +left epsilonleft( 1-3y_T^2 right)-1 right widetildeX_t + leftepsilonleft(2y_T^3+ 6y_T^2doty_T right ) +s-beta rightright dd t + sigma dd W_t\nendalign*","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"and can be called with","category":"page"},{"location":"predefined_processes/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"@load_diffusion :FitzHughNagumoConjugAuxLin","category":"page"},{"location":"manual/reparameterization/#Reparameterizations-1","page":"Reparameterizations","title":"Reparameterizations","text":"","category":"section"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"Instances of DiffusionProcess are immutable, and usually, so are their fields with parameters. Consequently, reparameterizations almost always involve constructing new objects.","category":"page"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"In an MCMC setting reparameterizations of diffusion laws happen very frequently and thus we provide a convenience function suitable for that setting:","category":"page"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"DiffusionDefinition.clone","category":"page"},{"location":"manual/reparameterization/#DiffusionDefinition.clone","page":"Reparameterizations","title":"DiffusionDefinition.clone","text":"clone(\n    P::T, ξ, glob_to_loc, θ°idx, ::Val{:associate_by_name}\n) where T <: DiffusionProcess\n\nClone diffusion law P substituting relevant parameters with new values. ξ is a vector with parameters (possibly more than needed). ξ itself can be a subvector of a larger vector ξ°. The coordinates relevant for P are given in θ°idx and they refer to positions in the larger vector ξ°. The connection between coordinates in ξ° and ξ is given in glob_to_loc.\n\n\n\n\n\n","category":"function"},{"location":"manual/reparameterization/#","page":"Reparameterizations","title":"Reparameterizations","text":"[TODO make it less convoluted]","category":"page"},{"location":"manual/load_diff/#Loading-diffusions-1","page":"Loading diffusions","title":"Loading diffusions","text":"","category":"section"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"Many standard diffusion processes have already been defined by us in this package via @diffusion_process and you may simply load them and start using them immediately without having to define them yourself. To see a list of all available processes call","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"@load_diffusion","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"See the Predefined processes for more detailed descriptions. To load a particular diffusion simply write: @load_diffusion DiffusionName. For instance:","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"@load_diffusion LotkaVolterraAux","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"Then the process can be instantiated:","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"α, β, γ, δ, σ1, σ2 = 2.0/3.0, 4.0/3.0, 1.0, 1.0, 0.2, 0.3\nlotka_volterra = LotkaVolterraAux(\n    α, β, γ, δ, σ1, σ2,\n    0.0, 1.0, zero(DD.ℝ{2}), zero(DD.ℝ{2})\n)","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"A very small subgroup of predefined diffusions have a variable dimension parameter. For these we provide a @load_variable_diffusion macro, that in addition to a diffusion name accepts also a dimension of the process and dimension of the wiener process. For instance","category":"page"},{"location":"manual/load_diff/#","page":"Loading diffusions","title":"Loading diffusions","text":"@load_variable_diffusion Lorenz96 2^10\n# if it made sense an additional 2nd number would specify the dimension of a Wiener process","category":"page"},{"location":"manual/buffers/#explain_buffers-1","page":"Buffers","title":"Buffers","text":"","category":"section"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"Buffers are simply structs gathering containers that are used for in-place computations. They inherit from","category":"page"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"DiffusionDefinition.AbstractBuffer","category":"page"},{"location":"manual/buffers/#DiffusionDefinition.AbstractBuffer","page":"Buffers","title":"DiffusionDefinition.AbstractBuffer","text":"AbstractBuffer{T} <: AbstractArray{T,1}\n\nTypes inheriting from AbstractBuffer define buffers used for various in-place computations.\n\n\n\n\n\n","category":"type"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"and don't require any special methods, except for functions b! and σ! (or for linear diffusions B! and β! in place of b!) having to specify explicitly how the drift and volatility are supposed to be saved inside the buffers. We provide implementation of standard buffers that should be sufficient for many problems:","category":"page"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"DiffusionDefinition.StandardEulerBuffer\nDiffusionDefinition.LinearDiffBuffer","category":"page"},{"location":"manual/buffers/#DiffusionDefinition.StandardEulerBuffer","page":"Buffers","title":"DiffusionDefinition.StandardEulerBuffer","text":"struct StandardEulerBuffer{Tb,Tσ,Tdw} <: AbstractBuffer\n    b::Tb\n    y::Tb\n    σ::Tσ\n    dW::Tdw\nend\n\nStandard buffer for the Euler-Maruyama simulations. The intermediary data is stored in b, σ, y and dW.\n\n\n\n\n\n","category":"type"},{"location":"manual/buffers/#DiffusionDefinition.LinearDiffBuffer","page":"Buffers","title":"DiffusionDefinition.LinearDiffBuffer","text":"struct LinearDiffBuffer{Tb,Tσ,Tdw,TB} <: AbstractBuffer\n    b::Tb\n    y::Tb\n    σ::Tσ\n    dW::Tdw\n    B::TB\nend\n\nA buffer for Euler-Maruyama simulations of linear diffusions. Almost the same as StandardEulerBuffer, but contains additional space for an intermediate construction of a matrix B.\n\n\n\n\n\n","category":"type"},{"location":"manual/buffers/#","page":"Buffers","title":"Buffers","text":"tip: Tip\nIf you call in-place methods multiple times, then make sure to pre-define a buffer and then pass it explicitly to solve!.","category":"page"},{"location":"predefined_processes/sir/#Susceptible-Infectious-Recovered-model-1","page":"SIR model","title":"Susceptible-Infectious-Recovered model","text":"","category":"section"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"A simple, scalar-valued susceptible-infectious-recovered (SIR) model defined by a two-dimension diffusion process solving the following SDE","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"beginalign*\ndd I_t = (alpha (1-I_t-R_t)I_t - beta I_t)dd t -sigma_1sqrt(1-I_t-R_t)I_t dd W^(1)_t - sigma_2sqrtI_tdd W^(2)_t\ndd R_t = beta I_t + sigma_2sqrtI_t dd W^(2)_t\nendalign*","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"with I_tin01 and R_tin01 for all tin0T. It can be called with:","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"@load_diffusion SIR","category":"page"},{"location":"predefined_processes/sir/#Example-1","page":"SIR model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion SIR\nθ = [0.37, 0.05, 0.03, 0.03]\nP = SIR(θ...)\ntt, y1 = 0.0:0.001:100.0, @SVector [0.001, 0.001]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), label=[\"infected\" \"recovered\"])\nplot!(X.t, map(x->1.0-x[1]-x[2], X.x), label=\"susceptible\")","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"(Image: sir)","category":"page"},{"location":"predefined_processes/sir/#Auxiliary-diffusion-1","page":"SIR model","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"We additionally define a suitable linear process that can be used in the setting of guided proposals. It is a solution to the following SDE","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"beginalign*\ndd widetildeI_t = (alpha (1-widetildeI_t-widetildeR_t)widetildeI_t - beta widetildeI_t)dd t -sigma_1(1-widetildeI_t-widetildeR_t)widetildeI_t dd W^(1)_t - sigma_2widetildeI_tdd W^(2)_t\ndd widetildeR_t = beta widetildeI_t + sigma_2widetildeI_t dd W^(2)_t\nendalign*","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"and can be called with","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"@load_diffusion SIRAux","category":"page"},{"location":"predefined_processes/sir/#Example-2","page":"SIR model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion SIRAux\nθ = [0.37, 0.05, 0.03, 0.03]\nt, T, vT = 0.0, 5.0, @SVector [0.5, 0.1]\nP = SIRAux(θ..., t, T, vT)\ntt, y1 = t:0.001:T, @SVector [0.04, 0.02]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), label=[\"infected\" \"recovered\"])\nplot!(X.t, map(x->1.0-x[1]-x[2], X.x), label=\"susceptible\")","category":"page"},{"location":"predefined_processes/sir/#","page":"SIR model","title":"SIR model","text":"(Image: sir_aux)","category":"page"},{"location":"predefined_processes/jansen_rit/#Jansen-Rit-model-1","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"","category":"section"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"Neural Mass Model used to describe the EEG data. It is a six-dimensional diffusion process driven by a three-dimensional Wiener process that is a solution to the following stochastic differential equation","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"beginequation*\n    beginaligned\n        dd X_t = dot X_t dd t  \n        dd Y_t = dot Y_t dd t  \n        dd Z_t = dot Z_t dd t \n        dd dot X_t =   leftA a left(mu_x(t) + mboxSigm(Y_t - Z_t)right) - 2a dot X_t - a^2 X_tright d t + sigma_x dd W^(1)_t\n        dd dot Y_t =  leftA a left(mu_y(t) + C_2mboxSigm(C_1 X_t)right) - 2a dot Y_t - a^2 Y_tright d t + sigma_y dd W^(2)_t\n        dd dot Z_t =  leftB b left(mu_z(t) + C_4mboxSigm(C_3 X_t)right) - 2b dot Z_t - b^2 Z_tright dd t + sigma_z dd W^(3)_t\n    endaligned\nendequation*","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"with initial condition","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"(X_0Y_0Z_0 dot X_0 dot Y_0 dot Z_0)=(x_0y_0z_0 dot x_0 dot y_0 dot z_0) in RR^6","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"where","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"mboxSigm(x) = fracnu_max1 + e^r(v_0 - x)","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"and","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"mu_x(t) =mu_xqquad mu_y(t) =mu_y mu_z(t) =mu_z","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"and","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"C_1 = C quad C_2 = 08C quad C_4 = C_3 = 025C","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"Can be imported with","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"@load_diffusion JansenRit","category":"page"},{"location":"predefined_processes/jansen_rit/#Example-1","page":"Jansen-Rit model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion JansenRit\nθ = [3.25, 100.0, 22.0, 50.0 , 135.0, 5.0, 6.0, 0.56, 0.0, 220.0, 0.0, 0.01, 2000.0, 1.0]\nP = JansenRit(θ...)\ntt, y1 = 0.0:0.0001:3.0, @SVector [0.11, 24, 17, -0.5, 0.0, 0.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), layout=(3,2), size=(1000,800))","category":"page"},{"location":"predefined_processes/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"(Image: jansen_and_rit)","category":"page"},{"location":"tutorials/simple_lorenz/#tutorials_start-1","page":"(TODO) Sampling Lorenz system","title":"Simple tutorial","text":"","category":"section"},{"location":"manual/drift_and_volatility/#Defining-the-drift-and-the-volatility-coefficient-1","page":"Drift and volatility","title":"Defining the drift and the volatility coefficient","text":"","category":"section"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"To complete the definition of a diffusion process we need to specify its drift, as well as its volatility coefficient. For the Lorenz example from the previous section we can do this by writing:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"const DD = DiffusionDefinition\nusing StaticArrays\n\nfunction DD.b(t, x, P::Lorenz)\n    @SVector [\n        P.p1*(x[2]-x[1]),\n        P.p2*x[1] - x[2] - x[1]*x[3],\n        x[1]*x[2] - P.p3*x[3]\n    ]\nend\n\nDD.σ(t, x, P::Lorenz) = SDiagonal(P.σ, P.σ, P.σ)","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"The two functions above are out-of-place i.e. they return new vectors (that live on a stack, because of StaticArrays). We may alternatively define the drift and diffusion coefficients to be in-place as follows:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"function DD.b!(buffer, t, x, P::Lorenz)\n    buffer.b[1] = P.p1*(x[2]-x[1])\n    buffer.b[2] = P.p2*x[1] - x[2] - x[1]*x[3]\n    buffer.b[3] = x[1]*x[2] - P.p3*x[3]\nend\n\nDD.σ!(buffer, t, x, P::Lorenz) = (buffer.σ.diag .= P.σ)","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"In this case case the output is saved to a buffer, which must have appropriate fields b and σ with enough pre-allocated space (see also the section on buffers).","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"note: Note\nall of the functions DD.b, DD.b!, DD.σ and DD.σ! are defined to overload the functionality inside the DiffusionDefinition module (accessing it via DD) and NOT the Main module.\nthe arguments for the out-of-place method are (t, x, P::DIFFUSION_NAME), whereas those for in-place are (buffer, t, x, P::DIFFUSION_NAME).","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"tip: Tip\nAlways use StaticArrays for out-of-place drift and volatility! If functions using DD.b and DD.σ are faster with regular arrays, then you shouldn't be using out-of-place methods in the first place, but DD.b! and DD.σ! instead. A general rule of thumb is to use DD.b and DD.σ for low dimensional diffusions (up to dimension ~10 for elliptic diffusions with dense volatility coefficients or up to dimension ~100 for those with sparse volatility coefficients) and use in-place methods otherwise.","category":"page"},{"location":"manual/drift_and_volatility/#default_types_for_P-1","page":"Drift and volatility","title":"Telling Julia whether to use (DD.b, DD.σ) or (DD.b!, DD.σ!)","text":"","category":"section"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"Some functions implemented in this package have two versions: one relying on out-of-place methods, another on in-place methods. For instance:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"DiffusionDefinition.solve!(XX, WW, P, y1)","category":"page"},{"location":"manual/drift_and_volatility/#DiffusionDefinition.solve!-NTuple{4,Any}","page":"Drift and volatility","title":"DiffusionDefinition.solve!","text":"solve!(XX, WW, P, y1)\n\nCompute a trajectory, started from y1 and following the diffusion law P, from the sampled Wiener process WW. Save the sampled path in XX. Return prematurely with a false massage if the numerical scheme has led to the solver violating the state-space restrictions.\n\n\n\n\n\n","category":"method"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"and","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"DiffusionDefinition.solve!(XX, WW, P, y1, buffer)","category":"page"},{"location":"manual/drift_and_volatility/#DiffusionDefinition.solve!-NTuple{5,Any}","page":"Drift and volatility","title":"DiffusionDefinition.solve!","text":"solve!(XX, WW, P, y1, buffer)\n\nSame as solve!(XX, WW, P, y1), but additionally provides a pre-allocated buffer for performing in-place computations.\n\n\n\n\n\n","category":"method"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"Calling one or the other will tell Julia which pair of functions (DD.b, DD.σ) or (DD.b!, DD.σ!) to use. However, most functions do not explicitly come in two versions, and instead, they rely on some hint from the user to decide on the mode of computation. There are two ways in which Julia can be given such hints:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"If the function accepts optional inputs (such as a starting point) or expects to receive containers that the results are saved into (such as containers for diffusion paths), then the DataType of said inputs will be used to decide on the mode of computation (if DataType used for state space is immutable, then out-of-place methods are used, otherwise in-place methods are used). These hints will overwrite the second method below.\nSometimes no such inputs can be passed or there is an option of relying on defaults. In that case Julia will use default information specified by functions:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"DiffusionDefinition.default_type\nDiffusionDefinition.default_wiener_type","category":"page"},{"location":"manual/drift_and_volatility/#DiffusionDefinition.default_type","page":"Drift and volatility","title":"DiffusionDefinition.default_type","text":"default_type(::DiffusionProcess{T,DP})\n\nAllows for inference of data type that encodes the state space of a given diffusion.\n\n\n\n\n\n","category":"function"},{"location":"manual/drift_and_volatility/#DiffusionDefinition.default_wiener_type","page":"Drift and volatility","title":"DiffusionDefinition.default_wiener_type","text":"default_wiener_type(::DiffusionProcess{T,DP,DW})\n\nAllows for inference of data type that encodes the state space of the Brownian motion driving a given diffusion process.\n\n\n\n\n\n","category":"function"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"By default, these two are set to StaticArrays resulting in out-of-place computations by default. To change that, overwrite the two functions for your diffusion type. For instance, for the Lorenz example, to change the default mode of computation to out-of-place write:","category":"page"},{"location":"manual/drift_and_volatility/#","page":"Drift and volatility","title":"Drift and volatility","text":"default_type(::Lorenz) = Vector{Float64}\ndefault_wiener_type(::Lorenz) = Vector{Float64}","category":"page"},{"location":"predefined_processes/lorenz63/#Lorenz-'63-system-1","page":"Lorenz63 system","title":"Lorenz '63 system","text":"","category":"section"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"Famous Lorenz attractor, a three-dimensional elliptic diffusion, a solution to the following stochastic differential equation","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"beginalign*\ndd X_t = theta_1 (Y_t - X_t) dd t + sigma dd W^(1)_t \ndd Y_t = X_t (theta_2 - Z_t) - Y_tdd t + sigma dd W^(2)_t\ndd Z_t = X_t Y_t - theta_3 Z_tdd t + sigma dd W^(3)_t\nendalign*","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"Can be imported with the following command","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"@load_diffusion :Lorenz","category":"page"},{"location":"predefined_processes/lorenz63/#Example-1","page":"Lorenz63 system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion Lorenz\nθ = [10.0, 28.0, 8.0/3.0, 1.0]\nP = Lorenz(θ...)\ntt, y1 = 0.0:0.001:10.0, @SVector [-10.0, -10.0, 25.0]\nX = rand(P, tt, y1)\nplot(X, Val(:x_vs_y), coords=[1,3])","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"(Image: lorenz)","category":"page"},{"location":"predefined_processes/lorenz63/#Auxiliary-diffusion-1","page":"Lorenz63 system","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"We additionally provide an implementation of a linear diffusion that can be used in a setting of guided proposals. It is defined as a solution to the following SDE:","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"beginalign\ndd wtX_t = left-theta_1 wtX_t + theta_2wtY_trightdd t + sigma dd W^(1)_t\ndd wtY_t = left (theta_2-z_T)wtX_t - wtY_t - x_TwtZ_t + x_Tz_T rightdd t + sigma dd W^(2)_t\ndd wtZ_t = left y_TwtX_t x_TwtX_t -theta_3wtZ_t -x_Ty_T rightdd t + sigma dd W^(3)_t\nendalign","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"It can be called with","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"@load_diffusion :LorenzAux","category":"page"},{"location":"predefined_processes/lorenz63/#Example-2","page":"Lorenz63 system","title":"Example","text":"","category":"section"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"@load_diffusion LorenzAux\nusing DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion LorenzAux\nθ = [10.0, 28.0, 8.0/3.0, 1.0]\nt, T, vT = 0.0, 10.0, @SVector [-10.0, -10.0, 25.0]\nP = LorenzAux(θ..., t, T, vT)\ntt, y1 = t:0.001:T, vT\nX = rand(P, tt, y1)\nplot(X, Val(:x_vs_y), coords=[1,3])","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"(Image: lorenz_aux)","category":"page"},{"location":"predefined_processes/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"note: Note\nNotice the limits of the axes! The auxiliary diffusion becomes an atrocious approximation to the Lorenz system over long time periods!","category":"page"},{"location":"predefined_processes/sine/#Sine-diffusion-1","page":"Sine diffusion","title":"Sine diffusion","text":"","category":"section"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"A simple, scalar diffusion process displaying multimodality on a path space. It solves the following stochastic differential equation","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"dd X_t = (a + bsin(c X_t))dd t + sigma dd W_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"It can be called with","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"@load_diffusion :Sine","category":"page"},{"location":"predefined_processes/sine/#Example-1","page":"Sine diffusion","title":"Example","text":"","category":"section"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"using DiffusionDefinition\nusing Plots\n\n@load_diffusion Sine\nθ = [1.0, 2.0, 8.0, 0.5]\nP = Sine(θ...)\ntt, y1 = 0.0:0.001:20.0, 0.0\nX = rand(P, tt, y1)\nplot(X)","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"(Image: sine)","category":"page"},{"location":"predefined_processes/sine/#Auxiliary-diffusion-1","page":"Sine diffusion","title":"Auxiliary diffusion","text":"","category":"section"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"We define an additional, linear diffusion that can be used in the setting of guided proposals. It solves the following SDE","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"dd widetildeX_t = left(fracx_T-x_0T + fract5TwidetildeX_tright)dd t + sigma dd W_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"and can be called with","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"@load_diffusion :SineAux","category":"page"},{"location":"predefined_processes/sine/#Example-2","page":"Sine diffusion","title":"Example","text":"","category":"section"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"using DiffusionDefinition\nusing Plots\n\n@load_diffusion SineAux\nθ = [1.0, 2.0, 8.0, 0.5]\nt, T, y1, vT = 0.0, 20.0, 0.0, 4.0\nP = SineAux(θ..., t, T, y1, vT)\ntt = t:0.001:T\nX = rand(P, tt, y1)\nplot(X)","category":"page"},{"location":"predefined_processes/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"(Image: sine_aux)","category":"page"},{"location":"manual/state_space/#state_space_restrictions-1","page":"State space restrictions","title":"Restricting diffusion's state space","text":"","category":"section"},{"location":"manual/state_space/#","page":"State space restrictions","title":"State space restrictions","text":"Many standard diffusions are defined only on a subset of RR^d, and thus, it is often needed to restrict the state space on which trajectories can be sampled. We provide a set of structs that may be passed at the time of defining a diffusion law (calling the macro @diffusion_process) to restrict the state space of the diffusion","category":"page"},{"location":"manual/state_space/#","page":"State space restrictions","title":"State space restrictions","text":"DiffusionDefinition.UnboundedStateSpace\nDiffusionDefinition.LowerBoundedStateSpace\nDiffusionDefinition.UpperBoundedStateSpace\nDiffusionDefinition.BoundedStateSpace","category":"page"},{"location":"manual/state_space/#DiffusionDefinition.UnboundedStateSpace","page":"State space restrictions","title":"DiffusionDefinition.UnboundedStateSpace","text":"UnboundedStateSpace <: DiffusionStateSpace\n\nNo restrictions imposed on the state-space of the process (i.e. ℝᵈ)\n\n\n\n\n\n","category":"type"},{"location":"manual/state_space/#DiffusionDefinition.LowerBoundedStateSpace","page":"State space restrictions","title":"DiffusionDefinition.LowerBoundedStateSpace","text":"LowerBoundedStateSpace{T,S,N} <: DiffusionStateSpace\n\nLower bounds imposed on the state-space of a diffusion process. T is used to list the indices that have lower-bound restrictions, S indicates the values of the lower-bounds, N is the total number of coordinates with lower-bound restrictions\n\n\n\n\n\n","category":"type"},{"location":"manual/state_space/#DiffusionDefinition.UpperBoundedStateSpace","page":"State space restrictions","title":"DiffusionDefinition.UpperBoundedStateSpace","text":"UpperBoundedStateSpace{T,S,N} <: DiffusionStateSpace\n\nUpper bounds imposed on the state-space of a diffusion process. T is used to list the indices that have upper-bound restrictions, S indicates the values of the upper-bounds, N is the total number of coordinates with upper-bound restrictions\n\n\n\n\n\n","category":"type"},{"location":"manual/state_space/#DiffusionDefinition.BoundedStateSpace","page":"State space restrictions","title":"DiffusionDefinition.BoundedStateSpace","text":"BoundedStateSpace{L,U} <: DiffusionStateSpace\n\nUpper and lower bounds imposed on the state-space of a diffusion process. L corresponds to lower bounds, U corresponds to upper bounds.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"post_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"post_index/#","page":"Index","title":"Index","text":"Modules = [DiffusionDefinition]","category":"page"},{"location":"post_index/#DiffusionDefinition.Wiener","page":"Index","title":"DiffusionDefinition.Wiener","text":"struct Wiener{D,Tdevice}\nend\n\nA struct defining the Wiener process. D indicates the dimension of the process if it cannot be inferred from the DataType of the Trajectory. If the dimension can be inferred then it takes precedence over the value of D.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#Trajectories.trajectory-Tuple{Any,Type,Number}","page":"Index","title":"Trajectories.trajectory","text":"Trajectories.trajectory(tt, v::Type, D::Number)\n\nCreate a Trajectory with mutable states of dimension D along the time collection tt.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Trajectories.trajectory-Tuple{Any,Type}","page":"Index","title":"Trajectories.trajectory","text":"Trajectories.trajectory(tt, v::Type)\n\nCreate a Trajectory with immutable states along the time collection tt.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.@diffusion_process-Tuple{Any,Expr,Vararg{Any,N} where N}","page":"Index","title":"DiffusionDefinition.@diffusion_process","text":"diffusion_process(name, ex::Expr, p...)\n\nDefines a diffusion process according to a template described in the documentation of the github repository: https://github.com/mmider/DiffusionDefinition.jl\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.@load_diffusion-Tuple{Any}","page":"Index","title":"DiffusionDefinition.@load_diffusion","text":"load_diffusion(name)\n\nLoads the predefined diffusion process.\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.@load_diffusion-Tuple{}","page":"Index","title":"DiffusionDefinition.@load_diffusion","text":"load_diffusion()\n\nDisplays available choices of predefined diffusion processes that can be loaded\n\n\n\n\n\n","category":"macro"},{"location":"post_index/#DiffusionDefinition.AbstractSDESolver","page":"Index","title":"DiffusionDefinition.AbstractSDESolver","text":"abstract type AbstractSDESolver end\n\nSupertype of flags indicating ODE solvers\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.DiffusionProcess","page":"Index","title":"DiffusionDefinition.DiffusionProcess","text":"DiffusionProcess{T,DP,DW,SS,EI}\n\nTypes inheriting from DiffusionProcess define Ito diffusions. T denotes the datatype of each coordinate, DP the dimension of the stochastic process, DW the dimension of the Wiener process, SS lists the state space restrictions\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.DiffusionStateSpace","page":"Index","title":"DiffusionDefinition.DiffusionStateSpace","text":"DiffusionDomain\n\nTypes inheriting from DiffusionStateSpace define the types of restrictions put on the state-space of the stochastic process.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.EulerMaruyama","page":"Index","title":"DiffusionDefinition.EulerMaruyama","text":"struct EulerMaruyama <: AbstractSDESolver end\n\nFlag for indicating use of the Euler-Maruyama scheme for sampling diffusions. IMPORTANT: this is the only diffusion path sampler implemented in this package. There are no plans for implementing any other SDE solver in the forseeable future.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#DiffusionDefinition.LinearDiffusion","page":"Index","title":"DiffusionDefinition.LinearDiffusion","text":"LinearDiffusion{T,DP,DW,SS} <: DiffusionProcess{T,DP,DW,SS}\n\nTypes inheriting from LinearDiffusion define a linear Ito-type diffusion, i.e. solutions to stochastic differential equations of the form: dXₜ = (BₜXₜ + βₜ)dt + σₜdWₜ, t∈[0,T], X₀=x₀.\n\n\n\n\n\n","category":"type"},{"location":"post_index/#Base.Unicode.lowercase-Tuple{Symbol}","page":"Index","title":"Base.Unicode.lowercase","text":"Base.lowercase(s::Symbol)\n\nLowercase all letters in a symbol\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Base.rand","page":"Index","title":"Base.rand","text":"Base.rand(w::Wiener, tt, y1)\n\nSamples Wiener process on tt, started from y1 and returns a new object with a sampled trajectory.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.B","page":"Index","title":"DiffusionDefinition.B","text":"B\n\nCompute matrix B of a linear diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.B!","page":"Index","title":"DiffusionDefinition.B!","text":"B!\n\nCompute matrix B of a linear diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition._bound_satisfied-Tuple{UnboundedStateSpace,Any}","page":"Index","title":"DiffusionDefinition._bound_satisfied","text":"bound_satisfied(::UnboundedStateSpace, x)\n\nNo restrictions, bounds satisfied by default\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._bound_satisfied-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{LowerBoundedStateSpace{T,S,N},Any}} where N where S where T","page":"Index","title":"DiffusionDefinition._bound_satisfied","text":"bound_satisfied(::LowerBoundedStateSpace{T,S,N}, x) where {T,S,N}\n\nChecks if all coordinates adhere to lower bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._bound_satisfied-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{UpperBoundedStateSpace{T,S,N},Any}} where N where S where T","page":"Index","title":"DiffusionDefinition._bound_satisfied","text":"bound_satisfied(::UpperBoundedStateSpace{T,S,N}, x) where {T,S,N}\n\nChecks if all coordinates adhere to upper bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._bound_satisfied-Union{Tuple{U}, Tuple{L}, Tuple{BoundedStateSpace{L,U},Any}} where U where L","page":"Index","title":"DiffusionDefinition._bound_satisfied","text":"bound_satisfied(::BoundedStateSpace{L,U}, x) where {L,U}\n\nChecks if all coordinates adhere to lower and upper bound restrictions\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._is_datatype-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition._is_datatype","text":"_is_datatype(sym, p)\n\nUtility function that checks whether sym is a datatype. It returns true if sym is either an in-built datatype (say float, StaticArray etc.) or if it is a template argument.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(::Any, ::Any)\n\nReturn false by default i.e. if the first argument is not a symbol nor its quote\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{QuoteNode,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(s::QuoteNode, symbols)\n\nCheck if quote of a symbol s is listed in a list of symbols symbols\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition._symbol_in-Tuple{Symbol,Any}","page":"Index","title":"DiffusionDefinition._symbol_in","text":"_symbol_in(s::Symbol, symbols)\n\nCheck if symbol s is listed in a list of symbols symbols\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.a","page":"Index","title":"DiffusionDefinition.a","text":"a\n\nCompute the diffusion function σσ' of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.a!","page":"Index","title":"DiffusionDefinition.a!","text":"a!\n\nCompute the diffusion function σσ' of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.add_diff_function!-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.add_diff_function!","text":"add_diff_function!(fns, p)\n\nAdd a definition of a function consdiff that indicates if the diffusion coefficient is constant\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.add_nonhypo_function!-Tuple{Any,Any,Any}","page":"Index","title":"DiffusionDefinition.add_nonhypo_function!","text":"add_nonhypo_function!(fns, line, p)\n\nAdd a definition of a function nonhypo that takes a current diffusion state x and returns the elliptic coordinates.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.add_phi_function!-Tuple{Expr,Array{Expr,1},Symbol,Symbol,Any}","page":"Index","title":"DiffusionDefinition.add_phi_function!","text":"add_phi_function!(expr::Expr, fns::Vector{Expr}, t::Symbol, x::Symbol, p)\n\nConstruct a phi function used for conjugate updates.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.b","page":"Index","title":"DiffusionDefinition.b","text":"b\n\nCompute the drift of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.b!","page":"Index","title":"DiffusionDefinition.b!","text":"b!\n\nCompute the drift of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.cleanup_param_names!-Tuple{Any,Symbol,Symbol,Any}","page":"Index","title":"DiffusionDefinition.cleanup_param_names!","text":"cleanup_param_names!(expr, t::Symbol, x::Symbol, params)\n\nA hepler function for cleaning up the names of variables in the definition of a phi function.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.constdiff","page":"Index","title":"DiffusionDefinition.constdiff","text":"constdiff\n\nReturns true if the diffusion coefficient does not depend on the state of the process or time.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.createstruct-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.createstruct","text":"createstruct(abstract_type, name, params)\n\nCreate code that defines a struct defining a diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(p)\n\nFill all unspecified variables with default values\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Val{:additional},Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(::Val{:additional}, p)\n\nIf unspecified, there are no restriction on a state space, the volatility coefficient is assumed constant, the diffusion is not linear and the datatype of each coordinate is set to Float64.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.fill_unspecified_with_defaults-Tuple{Val{:dimensions},Any}","page":"Index","title":"DiffusionDefinition.fill_unspecified_with_defaults","text":"fill_unspecified_with_defaults(::Val{:dimensions}, p)\n\nIf unspecified, the dimension of the stochastic process and the driving Brownian motion is set to 1.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.get_curly-Union{Tuple{Type{K}}, Tuple{K}} where K","page":"Index","title":"DiffusionDefinition.get_curly","text":"get_curly(::Type{K}) where K\n\nUtility function that returns a tuple with all type-specifiers listed in the curly brackets.\n\nExamples\n\njulia> remove_curly(Array{Float64,1})\n(:Float64, 1)\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.get_name_stem-Tuple{Symbol,Any}","page":"Index","title":"DiffusionDefinition.get_name_stem","text":"get_name_stem(name_stem::Symbol, parameters)\n\nGet the stem of a name for a parameters and then add a disambiguation index. Underscore _ used in place of name is defaulted to p.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.grad_y1-NTuple{5,Any}","page":"Index","title":"DiffusionDefinition.grad_y1","text":"grad_y1(y1, W, X, P, f)\n\nCompute ∇f with respect to the starting position y1 for a fixed Wiener path W. X is a container where the the trajectory computed for the Wiener path W under the law P will be stored.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.grad_θ-NTuple{6,Any}","page":"Index","title":"DiffusionDefinition.grad_θ","text":"grad_θ(θ, y1, W, X, Law, f)\n\nCompute ∇f with respect to parameters θ for a fixed Wiener path W. X is a container where the the trajectory computed for the Wiener path W under the law Law(θ) will be stored. y1 is the starting position.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.highest_idx_used-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.highest_idx_used","text":"highest_idx_used(name_stem, params)\n\nFind the highest disambiguation index that has been used thus far for a given name_stem.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:additional},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:additional}, line, p)\n\nParse a line that defines additional information about a diffusion process.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:aux_info},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:aux_info}, line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in a format:     name –> parameter-description\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:conjugate},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:conjugate}, line, p)\n\nParse a line that defines conjugate updates.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Tuple{Val{:dimensions},Any,Any}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:dimensions}, line, p)\n\nParse a line that defines the dimension of a diffusion process and the driving Brownian motion.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_line!-Union{Tuple{K}, Tuple{K,Any,Any}} where K<:Union{Val{:parameters}, Val{:const_parameters}}","page":"Index","title":"DiffusionDefinition.parse_line!","text":"parse_line!(::Val{:parameters}, line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in a format:     name –> parameter-description\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_lines!-Tuple{Expr,Any,Any}","page":"Index","title":"DiffusionDefinition.parse_lines!","text":"parse_lines!(ex::Expr, p, condition)\n\nParse all lines of the expression ex, but process only those which satisfy condition. p is a passed-around structure that accumulates processed information.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.parse_param_multi_names","page":"Index","title":"DiffusionDefinition.parse_param_multi_names","text":"parse_param_multi_names(line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in one of the formats:     (pname1, pname2, ...) –> (numberofparameters, datatype)     (pname1, pname2, ...) –> datatype     (pname1, pname2, ...) –> (datatype1, datatype2, ...) In the former two cases defines number_of_parameters-many parameters, with names p_name1, p_name2, ... and of datatype type. In the last case the datatypes differ from parameter to parameter.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.parse_param_single_name","page":"Index","title":"DiffusionDefinition.parse_param_single_name","text":"parse_param_single_name(line, p)\n\nParse a line that defines parameters of the diffusion. The line must be in one of the formats:     parametername –> (numberofparameters, datatype)     parametername –> datatype In the former case defines number_of_parameters-many parameters, with names parameter_namei and of datatype type. In the latter case defines a single parameters with name parameter_name and of type datatype.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.parse_process-Tuple{Any,Expr,Any}","page":"Index","title":"DiffusionDefinition.parse_process","text":"parse_process(name , ex::Expr, ::Any)\n\nParse a template defining a diffusion process, create a corresponding struct and specified functions, evaluate them in the environment of a package and then import the struct name to Main scope, in which the package has been imported to.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.prepare_abstract_type-NTuple{4,Any}","page":"Index","title":"DiffusionDefinition.prepare_abstract_type","text":"prepare_abstract_type(stem, dims, data_type, state_restr)\n\nCreate a string defining a parent, abstract type from its stem, the dimensions dims of the process and the driving Brownian motion, the datatype data_type of each coordinate and the restrictions on the state space state_restr.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.process_name","page":"Index","title":"DiffusionDefinition.process_name","text":"process_name\n\nProcess the name of a struct by returning the pure name (without template arguments), the name with template arguments and a list of template arguments.\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.remove_curly-Union{Tuple{Type{K}}, Tuple{K}} where K","page":"Index","title":"DiffusionDefinition.remove_curly","text":"remove_curly(::Type{K}) where K\n\nUtility function that removes all type-specifiers listed in the curly brackets.\n\nExamples\n\njulia> remove_curly(Array{Float64,1})\nArray\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.update_label-Tuple{Any,Any}","page":"Index","title":"DiffusionDefinition.update_label","text":"update_label(line, current_label)\n\nUpdate the label, which signifies what type of information a given line in a template is supposed to be encoding.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#DiffusionDefinition.β","page":"Index","title":"DiffusionDefinition.β","text":"β\n\nCompute vector β of a linear diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.β!","page":"Index","title":"DiffusionDefinition.β!","text":"β!\n\nCompute vector β! of a linear diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.σ","page":"Index","title":"DiffusionDefinition.σ","text":"σ\n\nCompute the volatility coefficient of a diffusion out-of-place (should use StaticArrays).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#DiffusionDefinition.σ!","page":"Index","title":"DiffusionDefinition.σ!","text":"σ!\n\nCompute the volatility coefficient of a diffusion in-place (uses buffers to store temporary results).\n\n\n\n\n\n","category":"function"},{"location":"post_index/#Random.rand!-Union{Tuple{D}, Tuple{K}, Tuple{T}, Tuple{Wiener{D,T} where T,Trajectory{T,Array{K,1}}}, Tuple{Wiener{D,T} where T,Trajectory{T,Array{K,1}},Any}} where D where K where T","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    w::Wiener{D},\n    path::Trajectory{T,Vector{K}},\n    y1=zero(K,D,ismutable(K))\n) where {T,K,D}\n\nSamples Wiener process started from y1 and saves the data in path. Uses a default random number generator.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Random.rand!-Union{Tuple{D}, Tuple{T}, Tuple{K}, Tuple{Random.AbstractRNG,Wiener{D,T} where T,Trajectory{T,#s26} where #s26<:(Array{#s27,1} where #s27<:(Array{K,N} where N))}, Tuple{Random.AbstractRNG,Wiener{D,T} where T,Trajectory{T,#s28} where #s28<:(Array{#s29,1} where #s29<:(Array{K,N} where N)),Any}} where D where T where K","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    rng::Random.AbstractRNG,\n    ::Wiener{D},\n    path::Trajectory{T,Vector{Vector{K}}},\n    y1=zeros(K,D)\n) where {K,T,D}\n\nSamples Wiener process with mutable states, started from y1 and saves the data in path. rng is used as a random number generator.\n\n\n\n\n\n","category":"method"},{"location":"post_index/#Random.rand!-Union{Tuple{K}, Tuple{T}, Tuple{Random.AbstractRNG,Wiener,Trajectory{T,#s12} where #s12<:Array{K,1}}, Tuple{Random.AbstractRNG,Wiener,Trajectory{T,#s24} where #s24<:Array{K,1},Any}} where K where T","page":"Index","title":"Random.rand!","text":"Random.rand!(\n    rng::Random.AbstractRNG,\n    ::Wiener,\n    path::Trajectory{T,Vector{K}},\n    y1=zero(K)\n) where {T,K}\n\nSamples Wiener process with immutable states, started from y1 and saves the data in path. rng is used as a random number generator.\n\n\n\n\n\n","category":"method"},{"location":"#DiffusionDefinition.jl-1","page":"Home","title":"DiffusionDefinition.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a compact utility package for defining diffusion processes and sampling from their laws. It is created to work in conjunction with a suite of packages in JuliaDiffusionBayes that provide tools for Bayesian inference for diffusion processes. However, it can also be used on its own to:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"define diffusion laws\nforward-sample their trajectories\ncompute functionals of sampled paths\ncompute gradients of functionals of sampled paths with respect to diffusion parameters or with respect to the starting point of the trajectory","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of DiffusionDefinition.jl's main functionality see Get started.\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using DiffusionDefinition.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"},{"location":"predefined_processes/favetto_samson/#Favetto-Samson-compartment-model-1","page":"Favetto-Samson model","title":"Favetto-Samson compartment model","text":"","category":"section"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"Two dimensional SDE:","category":"page"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"beginsplit\ndd X_t = (αδ(t) - (α+β)X_t + μ Y_t)dd t + σ_1 dW^1_t\ndd Y_t = (λX_t - μ Y_t) dd t + σ2 dW^2_t\nendsplit","category":"page"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"Can be imported with","category":"page"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"@load_diffusion FavettoSamson","category":"page"},{"location":"predefined_processes/favetto_samson/#Example-1","page":"Favetto-Samson model","title":"Example","text":"","category":"section"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"using DiffusionDefinition\nusing StaticArrays, Plots\n\n@load_diffusion FavettoSamson\nθ = [117, 5.83, 1.25, 1.5, 1.41, 0.0]\nP = FavettoSamson(θ..., t->2*(t/2)/(1+(t/2)^2))\ntt, y1 = 0.0:0.0001:10.0, @SVector [0.0, 0.0]\nX = rand(P, tt, y1)\nplot(X, Val(:vs_time), size=(800, 300))","category":"page"},{"location":"predefined_processes/favetto_samson/#","page":"Favetto-Samson model","title":"Favetto-Samson model","text":"(Image: favetto_samson)","category":"page"}]
}
